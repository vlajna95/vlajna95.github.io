Strukture podataka su jedan od najvažnijih elemenata svakog programskog jezika. One omogućavaju logičko grupisanje podataka i nude mehanizme pomoću kojih je na centralizovan način moguće manipulisati takvim podacima. U dosadašnjem toku ovog kursa smo se upoznali sa nekoliko struktura podataka koje postoje u programskom jeziku Java. Svakako najpoznatija struktura podataka jeste objekat, unutar koga se mogu grupisati podaci i operacije koji opisuju jedan entitet. Java programski jezik poznaje i razne druge vrste specijalizovanih objekata koji takođe predstavljaju specifične strukture podataka. Jedna od takvih struktura su i nizovi, a u ovoj i narednim lekcijama ovog modula imaćete prilike da vidite da u Javi postoji još nekoliko specijalizovanih struktura podataka, koje znatno olakšavaju rad sa skupovima podataka. Prvi tip takvih struktura, o kome će biti reči u ovoj lekciji, jesu enumeracije. 


## Šta su enumeracije? 

U Javi, enumeracije su specijalni tip podataka koji je sačinjen iz fiksnog broja imenovanih konstanti. Tako enumeracije omogućavaju da se unutar jednog tipa podataka objedini veći broj srodnih konstanti. 

Potreba za korišćenjem enumeracija veoma se često sreće u programiranju. Naime, često dolazi do potrebe da se unutar programa predstave neke grupe srodnih konstanti, odnosno podataka koji su unapred poznati, pre nego što se program pokrene. Primeri takvih podataka mogu biti nazivi dana u sedmici, nazivi meseca u godini, nazivi strana sveta, nazivi planeta u Sunčevom sistemu ili bilo koji drugi skup srodnih vrednosti za koje znamo da se neće menjati tokom izvršavanja Java programa. 


## Kako se kreiraju enumeracije u Javi? 

Enumeracije su složeni tipovi podataka, pa se stoga kreiraju vrlo slično klasama. Umesto ključne reči class, koristi se ključna reč enum: 
```java
public enum Size {

}
```

Ovo je primer jedne enumeracije sa nazivom Size. Telo enumeracije je trenutno prazno.
IntelliJ IDEA Tip
Kreiranje enumeracija
Korišćenjem IntelliJ IDEA razvojnog okruženja, enumeracije se kreiraju slično klasama. Potrebno je pokrenuti identičnu opciju kao i prilikom kreiranja klasa, odnosno opciju New -> Java Class, koja se nalazi u kontekstnom meniju koji se dobija desnim klikom na folder src (slika 7.1).
Slika 7.1. Opcija za kreiranje nove Java enumeracije (klase)

U panelu koji se zatim otvara, potrebno je uneti naziv enumeracije, a iz liste ponuđenih tipova potrebno je odabrati Enum (slika 7.2).
Slika 7.2. Prozor za definisanje naziva nove enumeracije

Potvrdu je moguće postići duplim klikom na Enum ili pritiskom na taster Enter na tastaturi.
Baš kao i klase, enumeracije je moguće definisati unutar zasebnih fajlova sa ekstenzijom .java, ali i unutar postojećih klasa. Bitno je razumeti da su enumeracije unutar postojećih klasa uvek statički elementi takvih klasa. Stoga im se može pristupiti navođenjem naziva klase u kojoj se nalaze.

Enumeracione konstante
Najznačajniji elementi koji se mogu naći unutar enumeracija jesu konstante, koje se drugačije nazivaju enumeracione konstante. Unutar upravo kreirane enumeracije, takve konstante mogu da izgledaju ovako:
public enum Size {
    SMALL, MEDIUM, LARGE, EXTRA_LARGE
}

Identifikatori SMALL, MEDIUM, LARGE i EXTRA_LARGE nazivaju se enumeracione konstante. S obzirom na to da je reč o konstantama, poštujući dobre prakse imenovanja, sve one su napisane velikim slovima.
Kreiranjem enumeracija u programu se dobija novi tip podataka. Stoga je enumeracionim konstantama moguće pristupiti na sledeći način:
Size size = Size.SMALL;

Kako se Java enumeracije realizuju u pozadini?
U programskom jeziku Java, enumeracije su specijalna vrsta klasa. Tako se kreiranjem enumeracije, u pozadini, od strane Java virtualne mašine kreira nova klasa koja nasleđuje baznu klasu svih enumeracija – Enum.
Kada se unutar jedne enumeracije definišu konstante, kao u prikazanom primeru, Java virtuelna mašina njih u pozadini pretvara u javna statička polja. Pri tome, svakom takvom javnom statičkom polju pridružuje se po jedan objekat koji je tipa enumeracije. Sve to znači da upravo kreirana enumeracija u pozadini izgleda ovako:
class Size {
        public static final Size SMALL = new Size();
        public static final Size MEDIUM = new Size();
        public static final Size LARGE = new Size();
        public static final Size EXTRA_LARGE = new Size();
}
Prikazivanje članova enumeracije
Već ste mogli da vidite da se kreiranjem enumeracije u pozadini obavlja kreiranje nove klase sa nazivom enumeracije. Takvoj klasi tokom prevođenja koda kompajler dodaje i neke specijalne metode. Jedna od njih je metoda values().
Metoda values() se može koristiti za dobijanje niza koji sadrži sve konstante jedne enumeracije. Stoga je metodu values() moguće koristiti za prikaz svih konstanti jedne enumeracije:    

{java * AJP-2_07/Size1.java  Size1.java  0}

{java * AJP-2_07/Program1.java  Program1.java  0}

Ovakav kod na izlazu ispisuje: 
SMALL
MEDIUM
LARGE
EXTRA_LARGE

Već znamo da svaki niz u Javi poseduje svojstvo length, pomoću kojeg je moguće dobiti njegovu dužinu. Takvo svojstvo je u primeru upotrebljeno prilikom formiranja uslova for petlje.
Enumeracije se u pozadini realizuju upotrebom:
klase Enum
niza Enum
interfejsa Enum
interfejsa Enumerable
Odgovori
  
## Enumeracije u uslovnim blokovima 

Najznačajnija upotrebna vrednost enumeracija jeste njihovo kombinovanje sa uslovnim konstrukcijama:
Size size = Size.SMALL;

if (size == Size.SMALL) {
    System.out.println("You size is S");
} else if (size == Size.MEDIUM) {
    System.out.println("You size is M");
} else if (size == Size.LARGE) {
    System.out.println("You size is L");
} else {
    System.out.println("You size is XL");
}

U okviru radnog okruženja možete testirati ovaj primer.

Ovo je primer korišćenja enumeracije kao kontrolne vrednosti u jednoj if - else if - else uslovnoj konstrukciji. Ipak, mnogo je češća upotreba enumeracija u kombinaciji sa switch konstrukcijom. Tako se upravo prikazani primer može transformisati ovako:
Size size = Size.LARGE;

switch (size){
    case SMALL -> System.out.println("You size is S");
    case MEDIUM -> System.out.println("You size is M");
    case LARGE -> System.out.println("You size is L");
    case EXTRA_LARGE -> System.out.println("You size is XL");
}

Dobijanje enumeracije na osnovu njenog naziva
U jednom od prethodnih primera ste mogli da vidite da klasa koja predstavlja enumeraciju od kompajlera prilikom prevođenja automatski dobija metodu values(). To nije jedina metoda koju enumeraciona klasa dobija. Još jedna takva metoda je i valueOf(), pomoću koje je moguće dobiti enumeracionu konstantu na osnovu njenog naziva u tekstualnom obliku. Evo šta to znači:
Size size = Size.valueOf("MEDIUM");

Metoda valueof() vrlo je korisna u situacijama u kojima podaci pristižu u aplikaciju u tekstualnom obliku, što je vrlo čest slučaj kada oni dolaze preko mreže ili iz nekog skladišta podataka. Korišćenjem statičke metode valueOf() biva pronađena enumeraciona konstanta sa prosleđenim imenom, a ukoliko ona ne postoji, biće izbačen izuzetak tipa IllegalArgumentException. Stoga je dobra praksa dodati i kod za obradu ovog izuzetaka:
Size size = null;

try {
    size = Size.valueOf("MeDIUM");
} catch (IllegalArgumentException exc) {
    System.out.println(exc.getMessage());
}

U okviru radnog okruženja možete testirati ovaj primer.

Sada smo dodali kod za obradu izuzetka, što će sprečiti prekid rada programa, ali će u slučaju nepostojeće vrednosti (što će se u primeru i dogoditi) promenljiva size imati vrednost null. Kako bi se prevazišli problemi koji u nastavku koda mogu biti prouzrokovani null vrednošću, često se pribegava uvođenju jedne dodatne enumeracione konstante:
public enum Size {
    SMALL, MEDIUM, LARGE, EXTRA_LARGE, UNSPECIFIED
}

Enumeracija sada poseduje još jednu konstantu, koju ćemo koristiti u situacijama kada vrednost još uvek nije definisana:
Size size = Size.UNSPECIFIED;
try {
    size = Size.valueOf("MeDIUM");
} catch (IllegalArgumentException exc) {
    System.out.println(exc.getMessage());
}

switch (size) {
    case SMALL -> System.out.println("You size is S");
    case MEDIUM -> System.out.println("You size is M");
    case LARGE -> System.out.println("You size is L");
    case EXTRA_LARGE -> System.out.println("You size is XL");
    default -> System.out.println("Incorrect value.");
}

Definisanje polja unutar enumeracija
Svaka konstanta unutar enumeracije zapravo je objekat klase koju u pozadini na osnovu enumeracije kreira Java kompajler. Objekti koji predstavljaju enumeracione konstante podrazumevano imaju dva svojstva:
• name – naziv enumeracione konstante;
• ordinal – redni broj enumeracione konstante.

Oba svojstva imaju privatni modifikator pristupa, pa im nije moguće pristupiti direktno. Ipak, pozivanjem metode toString() isporučuje se vrednost svojstva name, a korišćenjem metode ordinal() vrednost ordinal svojstva. Stoga je moguće upotrebiti sledeći kod:

{java * AJP-2_07/Size2.java  Size2.java  0}

{java * AJP-2_07/Program2.java  Program2.java  0}

Ovakav kod će na izlazu da proizvede sledeći rezultat:
0: SMALL
1: MEDIUM
2: LARGE
3: EXTRA_LARGE
4: UNSPECIFIED

U primeru se ispisuju redni broj enumeracione konstante i njen naziv, između kojih se navodi karakter dve tačke.
Pored svojstava name i ordinal, koja su automatski dostupna, unutar enumeracionih konstanti je moguće dodati i proizvoljna svojstva. Evo kako je tako nešto moguće postići:
public enum Size {
    SMALL("s"), MEDIUM("m"), LARGE("l"), EXTRA_LARGE("xl"), UNSPECIFIED("");

    public String code;

    Size(String code) {
        this.code = code;
    }
}

Ovo je sada primer enumeracije unutar koje smo samostalno definisali jedno svojstvo sa nazivom code. Bitno je da primetite sledeće:
• unutar klase je definisano javno svojstvo code;
• unutar klase je definisan konstruktor koji prihvata jedan parametar i njime postavlja vrednost svojstva code;
• konstruktor mora imati modifikator pristupa private ili package private, pošto se objekti koji predstavljaju enumeracione konstante ne mogu direktno kreirati izvan tela enumeracije;
• kod za definisanje enumeracionih konstanti pretvoren je u pozive konstruktora, pa se tako nakon naziva konstante definišu zagrade i unutar njih vrednost koja se prosleđuje konstruktoru enumeracije;
• na kraj odeljka za definisanje enumeracionih konstanti sada je neophodno postaviti karakter tačka i zapeta;
• odeljak za definisanje enumeracionih konstanti mora se definisati na početku tela enumeracije.

U okviru radnog okruženja možete testirati predhodni primer.
Kreiranom svojstvu code sada je moguće pristupiti nad promenljivama koje čuvaju referencu na enumeracione konstante:
 
 
  /
 
  Main.java
 
  Size.java
 
/Main.java
  
 
 
   Execute

Sada se, pored vrednosti svojstava name i ordinal, obavlja i ispis vrednosti svojstva code. Takođe, možete videti i kompaktniju sintaksu za prolazak kroz kompletnu kolekciju enumeracionih konstanti.

Definisanje metoda unutar enumeracija
Pored polja, unutar enumeracija je moguće definisati i proizvoljne metode. Tako, na primer, sada možemo polje code iz prethodnog primera pretvoriti u privatno i kreirati zasebnu javnu metodu koja će omogućiti pristup takvom privatnom polju:
public enum Size {
    SMALL("s"), MEDIUM("m"), LARGE("l"), EXTRA_LARGE("xl"), UNSPECIFIED("");

    private String code;

    public String getCode(){
        return code;
    }

    Size(String code) {
        this.code = code;
    }
}

Svojstvu code se više ne može pristupiti izvan enumeracije, ali zato može posredstvom nove metode getCode().
U okviru radnog okruženja možete testirati takav primer.

Vežbe
Vežba 1
Četiri standardna simbola u kartama su TREF, KARO, HERC i PIK. Potrebno je napraviti program koji korisniku omogućava da unese naziv simbola, a da zauzvrat dobije njegov simbol. Prilikom realizacije programa je potrebno koristiti enumeracije.
Rešenje
import java.util.Scanner;

public class JavaProgram {

    enum Symbol {
        DIAMOND, CLUB, HEART, SPADE
    }

    public static void main(String[] args) {

        for (Symbol symbol : Symbol.values())
            System.out.println(symbol + ": " + symbol.ordinal());

        System.out.println();

        System.out.println("Please, enter card symbol: ");
        try (Scanner sc = new Scanner(System.in)) {

            Symbol symbol = Symbol.valueOf(Symbol.class, sc.next().toUpperCase());
            System.out.println(symbol);

            switch (symbol) {
                case DIAMOND -> System.out.println("♦");
                case CLUB -> System.out.println("♣");
                case HEART -> System.out.println("♥");
                case SPADE -> System.out.println("♠");
            }
        } catch (Exception exc) {
            System.out.println("There is an error.");
        }
    }

}

Vežba 2
U web aplikaciju pristižu sledeći podaci u String obliku:
serverId=25&serverName=my name&serverStatus=Running

Potrebno je kreirati klasu Server, sa poljima: id, name i status.
Podatke koji pristižu u web aplikaciju je potrebno iskoristiti za kreiranje objekata tipa Server. Drugim rečima, tekst koji pristiže je potrebno parsirati i iz njega izvući pojedinačne informacije, odnosno ID, naziv i status servera. Polje id je potrebno predstavljati int tipom, polje name – String tipom, dok je za polje status potrebno kreirati enumeraciju sa statusima servera (Stopped, Running, Unknown). Nakon kreiranja objekta tipa Server i postavljanja vrednosti njegovih svojstava, potrebno je na izlazu ispisati njegove podatke, odnosno vrednosti njegovih svojstava.
Rešenje
Server.java:
public class Server {

    public enum ServerStatus {Stopped, Running, Unknown}

    public int id;
    public String name;
    public ServerStatus status;

    public Server(String pars) {
        String[] parsArray = pars.split("&");

        this.id = Integer.parseInt(parsArray[0].split("=")[1]);
        this.name = parsArray[1].split("=")[1].toString();
        this.status = getStatus(parsArray[2].split("=")[1].toString());
    }


    public ServerStatus getStatus(String status) {
        ServerStatus res = ServerStatus.Unknown;

        try {
            res = ServerStatus.valueOf(status);
        } catch (Exception e) {
            System.out.println("There is an error.");
        }

        return res;
    }

    @Override
    public String toString() {
        return "Server id: " + this.id + "\nServer name: " + this.name + "\nServer status: " + this.status + "\n";
    }
}

Main.java:
public class JavaProgram {

    public static void main(String[] args) {

        Server s = new Server("serverId=25&serverName=my name&serverStatus=Stopped");
        System.out.print(s);

    }

}