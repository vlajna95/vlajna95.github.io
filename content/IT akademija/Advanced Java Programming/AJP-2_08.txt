Mogućnost smeštanja većeg broja primitivnih vrednosti ili objekata unutar jedne promenljive osnova je većine modernih programskih jezika. Sa takvom mogućnošću Jave smo se do sada susretali prilikom rada sa nizovima. Oni omogućavaju da se jednom promenljivom predstavi skup podataka istog tipa:
String[] carBrands = {"Honda", "Toyota", "Subaru", "Acura", "Lexus"};

Ovo je jedan niz vrednosti String tipa. On ima naziv carBrands i ukupno pet članova. Iz prethodnih lekcija znate da je dužinu niza neophodno definisati prilikom njegove deklaracije i da se ona ne može menjati nakon kreiranja niza. Tako dolazimo i do osnovnog nedostatka nizova – oni ne poseduju dinamičku prirodu. To ste najbolje mogli da vidite u prethodnim lekcijama kada su obrađivani pojmovi događaja i Observable dizajn šablona. Tada smo za čuvanje reference na sve slušaoce koristili nizove i bili smo u obavezi da definišemo kompleksnu logiku za dodavanje i uklanjanje elemenata nizova, što je podrazumevalo da svaki put kreiramo novi niz. Kako bi se takvi problemi prevazišli i rad sa skupovima podataka učinio udobnijim, u Javi postoji pojam kolekcija. Tom pojmu biće posvećena lekcija koja je pred vama.

Šta su kolekcije?
Kolekcije su složeni tipovi podataka koji omogućavaju objedinjavanje i jedinstveno rukovanje većim brojem podataka. Pri tome, kolekcije nadomešćuju sve nešto ranije spomenute nedostatke nizova. One su dinamičke strukture podataka koje omogućavaju da se podacima veoma lako rukuje, pri čemu se prevashodno misli na mogućnost lake izmene njihove strukture.

Koje su prednosti kolekcija?
Prednosti kolekcija u odnosu na nizove su mnogobrojne. Neke od najznačajnijih takvih prednosti su sledeće:
• kolekcije su dinamičke strukture, što znači da nije neophodno unapred definisati njihovu veličinu;
• kolekcije mogu da sadrže podatke različitih tipova;
• kolekcije poseduju i brojne funkcionalnosti za obavljanje uobičajenih operacija nad podacima:
◦ dodavanje
◦ uklanjanje
◦ izmena
◦ brisanje
◦ pretraga
◦ prolazak (iteracija) kroz elemente.

Sve ovo znači da je rad sa kolekcijama znatno udobniji nego direktan rad sa nizovima. Kako biste mogli da naslutite efekat takvih pogodnosti, u nastavku će biti prikazano jednostavno poređenje. Evo koda koji je u nekoliko prethodnih lekcija korišćen za dodavanje novog elementa u niz koji je već deklarisan i inicijalizovan:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
import java.util.Arrays;
public class JavaProgram {
    static String[] carBrands = {"Honda", "Toyota", "Subaru", "Acura", "Lexus"};
    public static void main(String[] args) {
        System.out.println(Arrays.toString(carBrands));
        addNewBrand("Nissan");
        System.out.println(Arrays.toString(carBrands));
    }
    public static void addNewBrand(String brand) {
        String[] newCarBrands = new String[carBrands.length + 1];
        System.arraycopy(carBrands, 0, newCarBrands, 0, carBrands.length);
        newCarBrands[carBrands.length] = brand;
        carBrands = newCarBrands;
    }
}

Primer podrazumeva niz koji je prikazan na početku ove lekcije. Unutar njega se čuvaju nazivi proizvođača automobila. Primer podrazumeva i metodu addNewBrand(), unutar koje se nalazi logika za dodavanje novog elementa unutar niza. S obzirom na to da je veličina niza unapred utvrđena, unutar ove metode se obavlja kreiranje novog niza koji je za jedan element duži od originalnog niza. Zatim se u tako kreiran niz kopiraju elementi iz originalnog niza, a nakon toga se na kraj dodaje novi element. Referenca na tako kreiran niz se smešta unutar postojeće promenljive. Unutar main() metode je postavljen kod kojim se prvo ispisuju svi elementi niza. Zatim se u niz dodaje jedan element, a onda se opet obavlja ispis svih elementa. Rezultat na izlazu je ovakav:
[Honda, Toyota, Subaru, Acura, Lexus]
[Honda, Toyota, Subaru, Acura, Lexus, Nissan]

Jasno je da je postignuto dodavanje novog elementa nizu, ali je u pozadini zapravo obavljeno kreiranje novog niza i zamena postojećeg takvim novim nizom.
Pogledajte sada koliko je jednostavnije ovako nešto obaviti korišćenjem kolekcija:
import java.util.*;

{java * AJP-2_08/Program1.java  Program1.java  0}

U primeru se koristi jedna od kolekcija koje postoje u Java jeziku. Reč je o kolekciji ArrayList. Prvo je obavljeno kreiranje objekta takve kolekcije i unutar nje je upisano nekoliko članova String tipa, baš kao i u primeru koji je podrazumevao upotrebu niza. U nastavku možete da vidite da dodavanje novog elementa unutar kolekcije podrazumeva poziv samo jedne metode – add(), kojoj se prosleđuje novi element. Kompletnu logiku dodavanja novog elementa sama kolekcija obavlja za nas, tako da sada nema potrebe za pisanjem logike koja je u prethodnom primeru bila sadržana unutar metode addNewBrand().
Upravo prikazani primer ilustrovao je samo jednu od prednosti kolekcija nad nizovima. U nastavku ćete imati prilike da vidite da u Javi postoji veliki broj različitih vrsta kolekcija, koje je moguće koristiti u situacijama koje zahtevaju specifično ponašanje koje konkretna kolekcija obezbeđuje. Takođe, pored dodavanja, kao što je spomenuto ranije, kolekcije poseduju pregršt metoda za obavljanje svih ostalih manipulacija nad elementima kolekcija.

Kolekcije u Javi
Kolekcije su u Java programskom jeziku kompletan softverski okvir, koji je sačinjen iz velikog broja apstraktnih i konkretnih tipova i gotovih funkcionalnosti spremih za korišćenje kako bi programerima uštedeli vreme prilikom pisanja programa. Svi takvi tipovi smešteni su unutar paketa java.util.
Kompletna struktura tipova kojima su modelovane kolekcije u Java programskom jeziku može se podeliti na dve celine:
• tipove koji implementiraju interfejs Collection;
• tipove koji implementiraju interfejs Map.

Evo kako izgleda struktura tipova kolekcija koje se zasnivaju na interfejsu Collection (slika 8.1).
Slika 8.1. Struktura kolekcija tipa Collection

Kolekcije koje se zasnivaju na interfejsu Map poseduju strukturu kao na slici 8.2.
Slika 8.2. Struktura kolekcija tipa Map

Analizom strukture tipova kolekcija, koja se može videti na slikama 8.1. i 8.2, vidi se da kolekcije u Javi postoje u četiri osnovna oblika, koja se odnose na četiri interfejsa koje konkretne klase implementiraju. Ti interfejsi su sledeći:
• List;
• Set;
• Queue;
• Map.

Svaki upravo navedeni interfejs definiše određene osobine koje konkretne klase kolekcija moraju ispuniti. Neke kolekcije implementiraju jedan interfejs, a neke i veći broj ovih interfejsa i tako kombinuju osobine više tipova kolekcija. Generalno, najznačajniji tipovi kolekcija podataka koji nastaju implementiranjem navedenih interfejsa su sledeći:
• lista;
• stek;
• set (skup);
• red;
• mapa

Lista
Liste su kolekcije koje se zasnivaju na interfejsu List. Reč je o kolekcijama koje najviše podsećaju na klasične nizove, a poseduju dve odlučujuće osobine:
• one omogućavaju čuvanje više identičnih elemenata;
• kod njih se poštuje redosled unošenja elemenata, pa se stoga elementu može pristupiti navođenjem njegovog indeksa.

U nastavku ove lekcije upoznaćemo se sa jednom konkretnom implementacijom ove vrste kolekcija, koja je predstavljena klasom ArrayList.
Stek
Još jedna vrsta kolekcije koja je veoma česta u programiranju jeste ona koja definiše poseban redosled upisivanja i čitanja elemenata. Reč je o vrsti kolekcije koja se naziva stek (stack). Stek se zasniva na LIFO principu, što je skraćenica za Last In, First Out. To praktično znači da se poslednje upisan element čita prvi. U nastavku će biti prikazana jedna konkretna implementacija ove vrste kolekcija – Stack.
Red
Redovi su kolekcije koje se karakterišu pravilom FIFO, po kome se prvi upisani element prvi i čita (First In, First Out). Analogija se može napraviti sa čekaonicom iz svakodnevnog života. Osoba koja je u čekaonicu prva pristigla prva će i biti primljena, dok će poslednje pristigla osoba biti primljena poslednja. Metode za rukovanje ovakvim kolekcijama nalaze se unutar interfejsa Queue i Deque. Konkretna reprezentacija ovih interfejsa koja će biti ilustrovana u nastavku nosi naziv LinkedList.
Set (skup)
Set kolekcije, odnosno one kolekcije koje implementiraju Set interfejs, obezbeđuju sledeće osobine:
• svaki element mora biti jedinstven, odnosno, unutar jedne Set kolekcije nije moguće imati veći broj elementa sa istom vrednošću;
• redosled elemenata nije zagarantovan, odnosno, ovo su takozvane unorderedkolekcije, koje poseduju sopstvene mehanizme za sortiranje elemenata.

Zbog neophodnosti postojanja jedinstvenih vrednosti, ukoliko se u ovakav tip kolekcije unese objekat koji već postoji, njegova vrednost će se upisati preko stare vrednosti. U nastavku će biti ilustrovana HashSet kolekcija, kao predstavnik ove vrste.
Mapa
Mape su kolekcija koje se u Javi zasnivaju na interfejsu Map. One se neznatno razlikuju od svih do sada spomenutih kolekcija, zato što omogućavaju da vrednosti unutar njih budu jednoznačno određene jedinstvenim identifikatorima koji se nazivaju ključevi.
Mape se veoma često nazivaju asocijativnim strukturama podataka. Naziv je slikovit, a odnosi se na ključeve koji se mogu doživeti kao asocijacije na vrednosti koje predstavljaju. Unutar mapa, ključ može biti bilo koji tip podatka, za razliku od do sada spomenutih indeksiranih kolekcija, kod kojih se elementima može pristupiti samo na osnovu njihove pozicije. S obzirom na to da se ključevi koriste da jednoznačno odrede svaki element, jasno je da unutar ove vrste kolekcija svaki ključ mora biti jedinstven.
U nastavku lekcije ćemo se upoznati sa HashMap konkretnom implementacijom ove vrste kolekcija.
ArrayList
Najpoznatiji predstavnik kolekcija koje implementiraju interfejs List jeste kolekcija ArrayList. Njeno korišćenje ste već mogli da vidite na početku ove lekcije, kada je demonstrirana jedna od prednosti kolekcija nad nizovima. Činjenica je da je reč o kolekciji koja najviše podseća na nizove.
Objekat koji predstavlja ArrayList kolekciju može se dobiti instanciranjem istoimene klase:
ArrayList myList = new ArrayList();

Na ovaj način stvoren je jedan objekat koji čuva referencu na ArrayList kolekciju.
Dodavanje vrednosti
Dodavanje elemenata ArrayList kolekciji obavlja se korišćenjem metode add():
1
2
3
4
ArrayList myList = new ArrayList();
myList.add("Honda");
myList.add("Lexus");
myList.add("Toyota");

Jasno je da se u ovako kreiranu listu mogu dodavati članovi bez prethodno definisane veličine liste.
Korišćenjem metode add() elementi se dodaju redom, jedan za drugim. Ukoliko je element potrebno dodati na neku posebnu poziciju koja se definiše indeksom, moguće je koristiti metodu set():
1
2
3
4
5
6
ArrayList myList = new ArrayList();
myList.add("Honda");
myList.add("Lexus");
myList.add("Toyota");
myList.set(1, "Mazda");

Poslednjom naredbom obavljeno je upisivanje elementa preko već postojećeg elementa na poziciji sa indeksom 1.
U okviru radnog okruženja možete testirati primere iz ArrayList odeljka.
Čitanje vrednosti
Kako bi se pročitala vrednost određenog člana kolekcije, koristi se metoda get().

{java * AJP-2_08/Program2.java  Program2.java  0}

Elementi ArrayList kolekcije numerišu se kao i elementi nizova – korišćenjem numeričkih pozicija. Zbog toga je u primeru metodi get() prosleđena vrednost 1, a na izlazu biva ispisana sledeća vrednost:
Lexus

Na osnovu ispisa možemo da zaključimo da indeksiranje elemenata unutar ArrayList kolekcija funkcioniše identično kao i kod nizova. Prvi element ima indeks 0, a poslednji ima indeks koji je za jedan manji od dužine kompletne kolekcije.
Brisanje vrednosti
Brisanje određenog člana ArrayList kolekcije obavlja se korišćenjem metode remove():
myList.remove(1);

Metoda remove() prihvata indeks elementa koji je potrebno obrisati. Bitno je razumeti da se prilikom brisanja elementa ostali elementi pomeraju kako bi popunili prostor koji je nastao nakon brisanja elementa. Stoga, nakon brisanja, unutar ArrayList kolekcije nema slobodnih mesta, jer kompletan proces repozicioniranja za nas obavlja sama lista:
System.out.println(myList); // [Honda, Toyota]

Kada nakon brisanja elementa sa indeksom 1 obavimo ispis svih elemenata kolekcije, na osnovu ispisa na izlazu se jasno može videti da je upražnjeno mesto automatski popunjeno.
Iteracija i veličina kolekcije
Veličinu liste, odnosno broj elemenata koji se unutar nje nalaze, moguće je dobiti korišćenjem metode size():
1
2
for (int i = 0; i < myList.size(); i++)
    System.out.println(myList.get(i));

Primer ilustruje prolazak kroz kompletnu kolekciju korišćenjem for petlje, pri čemu se dužina kolekcije dobija pozivanjem metode size().
Kada se govori o iteraciji kolekcija, ona se može obaviti i korišćenjem unapređene for petlje:
1
2
for (Object s : myList)
    System.out.println(s);
Iteracija korišćenjem osobina Iterable interfejsa
Prolazak kroz sve vrste kolekcija (osim mapa) može se obaviti i korišćenjem specijalnih metoda koje su definisane unutar interfejsa Iterator. Na nešto ranije prikazanoj slici 8.1, možete videti da sve kolekcije implementiraju interfejs Iterable. Iterable interfejs unutar sebe poseduje samo jednu metodu, koja vraća referencu na tip koji implemetira interfejs Iterator. Reč je o interfejsu koji definiše sledeće metode:
• public boolean hasNext() – vraća vrednost true ukoliko postoji naredni element; u protivnom vraća vrednost false;
• public Object next() – vraća referencu na trenutni element i pomera kursor za jedno mesto unapred, na sledeći element;
• public void remove() – uklanja element sa pozicije na kojoj se kursor trenutno nalazi.

Na osnovu prikazanih metoda može se zaključiti da Iterator interfejs definiše jednostavan mehanizam za prolazak kroz kolekcije. Centralna figura je kursor, koji se može pomerati samo unapred i na taj način se postiže jednostavan prolazak kroz kolekciju, bez potrebe za korišćenjem petlji.
Primer prolaska kroz kolekciju korišćenjem funkcionalnosti Iterator interfejsa može da izgleda ovako:
1
2
3
4
Iterator itr = myList.iterator();
while (itr.hasNext()) {
    System.out.println(itr.next());
}

Ovakav prolazak kroz kolekciju nije ograničen na kolekcije ArrayList tipa, već ga je moguće primeniti na sve vrste kolekcije koje implementiraju interfejs Iterable.
Različiti tipovi vrednosti
Nešto ranije je rečeno da kolekcije mogu da prihvate podatke različitih tipova. Upravo zbog toga je moguće napisati ovako nešto:
1
2
3
4
5
6
7
8
9
ArrayList myList = new ArrayList();
myList.add("Honda");
myList.add(13);
myList.add("Toyota");
myList.add(true);
myList.add(44.33);
for (Object s : myList)
    System.out.println(s);

Kolekcija će bez problema obraditi sve priložene vrednosti, iako postoji razlika u tipovima. U ovakvim situacijama, u pozadini se obavlja automatsko pretvaranje svih tipova u Object tip. Prilikom čitanja vrednosti, one se opet automatski iz Object tipa konvertuju u svoj izvorni tip. Takve operacije se drugačije nazivaju Boxing i Unboxing i o njima je već bilo reči.
Pretraga kolekcije
Do sada ste mogli da vidite da je elementima ArrayList kolekcije moguće pristupati na osnovu indeksa. Ipak, videli smo da su indeksi promenljiva kategorija kada je reč o kolekcijama, pošto se indeks elemenata može menjati usled promene njihove pozicije kada se obavlja uklanjanje elemenata. Zbog toga je u praksi veoma korisno do elemenata doći na osnovu njihove vrednosti. Za početak, potrebno je proveriti da li neka vrednost postoji unutar kolekcije. Tako nešto je moguće postići korišćenjem metode contains():
1
2
3
4
5
6
7
8
ArrayList myList = new ArrayList();
myList.add("Honda");
myList.add(13);
myList.add("Toyota");
myList.add(true);
myList.add(44.33);
System.out.println(myList.contains("Honda"));

U poslednjoj naredbi prikazanog primera koristi se metoda contains() kojoj je prosleđena vrednost Honda. Na ovaj način, metoda contains() će utvrditi da li takva vrednost postoji unutar kolekcije. Ukoliko vrednost postoji, metoda contains() će emitovati vrednost true.
Nakon što se uverimo da neki element postoji unutar niza, moguće je doći do njegovog indeksa unutar kolekcije, korišćenjem metode indexOf():
1
2
3
4
5
6
7
8
9
10
11
12
ArrayList myList = new ArrayList();
myList.add("Honda");
myList.add(13);
myList.add("Toyota");
myList.add(true);
myList.add(44.33);
if(myList.contains("Honda")){
    int elemIndex = myList.indexOf("Honda");
    String elem = (String) myList.get(elemIndex);
    System.out.println(elem);
}

Naravno, metodu indexOf() je bilo moguće upotrebiti i direktno, bez prethodnog pozivanja metode contains(). U slučaju da tražena vrednost ne postoji unutar kolekcije, metoda indexOf() vraća vrednost -1.
Pretvaranje kolekcije u niz
Listu je u svakom trenutku moguće konvertovati u niz. Tako nešto se najlakše postiže upotrebom metode toArray():
1
2
3
4
5
Object[] array = myList.toArray();
for (int i = 0; i < array.length; i++) {
    System.out.println(array[i]);
}

Brisanje svih vrednosti
Brisanje svih elemenata liste obavlja se metodom clear():
myList.clear();

Nakon poziva ove metode lista postaje prazna.
U okviru radnog okruženja možete testirati sve predhodne primere iz ovog odeljka - ArrayList.

Stack
Stack je vrsta kolekcije koja se zasniva na postulatima LIFO strukture podataka. Kao što smo rekli, LIFO je skraćenica za Last In, First Out, što praktično znači da se poslednje upisan element čita prvi. Zbog takvog mehanizma, elementi se u kolekciju upisuju i čitaju na poseban način, korišćenjem metoda push() i pop():
1
2
3
4
5
6
7
Stack myList = new Stack();
myList.push("Honda");
myList.push("Toyota");
myList.push("Mazda");
myList.push("Subaru");
System.out.println(myList.pop());

Ovakav primer na izlazu proizvodi sledeći ispis: 
Subaru

Ispis potvrđuje ono što je nešto ranije rečeno – poslednje upisani element prvi je koji je pročitan metodom pop().
Bitno je razumeti da metoda pop(), pored isporuke elementa, obavlja i njegovo uklanjanje iz kolekcije:
1
2
3
4
5
6
7
8
9
10
Stack myList = new Stack();
myList.push("Honda");
myList.push("Toyota");
myList.push("Mazda");
myList.push("Subaru");
System.out.println(myList.pop());
System.out.println(myList.pop());
System.out.println(myList.size());

Pošto metoda pop() uklanja element iz kolekcije, prikazani primer na izlazu proizvodi sledeći ispis:
Subaru
Mazda
2

Nakon dva poziva metode pop(), kolekcija poseduje dva elementa manje nego na početku izvršavanja programa.
U okviru radnog okruženja možete testirati sve primere iz ovog odeljka - Stack.

LinkedList
Kada je potrebno kreirati kolekciju čiji elementi poštuju FIFO ustrojstvo, moguće je koristiti klasu LinkedList. FIFO je, kao što smo rekli, skraćenica za First In, First Out, što praktično znači da se elementi čitaju onim redom kojim su i upisani u kolekciju.
LinkedList je klasa koja kombinuje funkcionalnosti dva tipa kolekcija, zato što implementira interfejse List, Deque i Queue. Stoga kolekcije ovog tipa poseduju sledeće metode za rukovanje elementima:
• add() – dodaje novi elemeni u red;
• peek() – čita, ali ne uklanja element koji se nalazi na vrhu reda;
• poll() – čita i uklanja element koji se nalazi na vrhu reda.

Primer korišćenja LinkedList kolekcije može da izgleda ovako:
1
2
3
4
5
6
7
8
9
10
11
LinkedList myList = new LinkedList();
myList.add("Honda");
myList.add("Toyota");
myList.add("Mazda");
myList.add("Subaru");
System.out.println(myList.peek());
System.out.println(myList.poll());
System.out.println(myList.poll());
System.out.println(myList.size());

U primeru se prvo kreira nova kolekcija tipa LinkedList i unutar nje se upisuje nekoliko vrednosti korišćenjem metode add(). Metoda add() je dostupna unutar ove vrste kolekcija zbog implementiranja interfejsa List. Zatim se jednom obavlja pozivanje metode peek() i dva puta pozivanje metode poll(). Metoda peek() će pročitati element sa vrha kolekcije, bez njegovog uklanjanja, dok će metoda poll() pročitati element sa vrha i obaviti njegovo uklanjanje. Stoga se na kraju na izlazu dobija sledeći ispis:
Honda
Honda
Toyota
2

Uvidom u ispis koji se dobija, možemo potvrditi FIFO osobine ove vrste kolekcije. Element koji je prvi upisan prvi biva i pročitan.
Prvi ispis vrednosti Honda potiče od metode peek(). Nakon njenog izvršavanja, element Honda i dalje ostaje na vrhu kolekcije. Stoga se on čita i u narednoj naredbi, ovoga puta korišćenjem metode poll(). Ipak, metoda poll() uklanja element iz kolekcije, tako da sledeći poziv ove metode rezultuje čitanjem narednog elementa – Mazda. Na kraju se ispisuje veličina kolekcije, kako bismo se uverili da su dva elementa zaista uklonjena iz nje. Potvrda toga jeste vrednost 2, koja ukazuje na to da nakon svih intervencija unutar kolekcije postoje ukupno dva elementa.
U okviru radnog okruženja možete testirati primer iz ovog odeljka - LinkedList.

HashSet
Još jedna vrsta kolekcija koja je spomenuta u uvodnom izlaganju ove lekcije jesu kolekcije koje elemente čuvaju bez posebnog redosleda i pri tome ne dozvoljavaju pojavu više identičnih elemenata. Takve kolekcije se nazivaju setovi, a njihova najpoznatija implementacija jeste ona predstavljena klasom HashSet:
1
2
3
4
5
6
7
8
9
10
11
HashSet myCollection = new HashSet();
myCollection.add("One");
myCollection.add("Two");
myCollection.add("Three");
myCollection.add("Four");
myCollection.add("Five");
Iterator<String> i = myCollection.iterator();
while (i.hasNext()) {
    System.out.println(i.next());
}

Primer ilustruje korišćenje HashSet kolekcije. Bitno je da primetite redosled pozivanja add() metode. On odgovara nazivima parametara. Ipak, drugi deo primera podrazumeva ispis svih elemenata kolekcije, a na osnovu ispisa se može videti da redosled kojim su elementi upisani ne odgovara redosledu pozivanja add() metode:
Five
One
Four
Two
Three

U okviru radnog okruženja možete testirati ovaj primer.
Jasno je da redosled kojim se elementi upisuju u HashSet zavisi od same kolekcije, pa stoga ne možemo da računamo da će elementi biti upisani nekim poznatim redosledom. Sa druge strane, ovakva osobina veoma je korisna ukoliko će podaci unutar ovakve kolekcije često da budu pretraživani, zato što HashSet obezbeđuje veliku brzinu pretrage. Nad kolekcijom tipa HashSet moguće je koristiti sve nešto ranije prikazane metode ArrayList kolekcije – add(), remove(), contains(), size(), toArray(), clear()...
Unutar HashSet kolekcija nije moguće dodavati više identičnih vrednosti. Ukoliko se u ovakvu kolekciju pokuša upisati vrednost koja već postoji, ona će biti upisana preko već postojeće vrednosti:

{java * AJP-2_08/Program3.java  Program3.java  0}

I pored jedne naredbe više za upisivanje elemenata, ovakva kolekcija će imati identičan broj elemenata kao i u prethodnom primeru, pošto se vrednost One upisuje preko postojeće vrednosti.

HashMap
Još jedan tip kolekcija o kojima će biti reči u ovoj lekciji su one kolekcije koje omogućavaju da se zapisi unutar kolekcije identifikuju korišćenjem specijalnih, jedinstvenih oznaka koje se nazivaju ključevi. Takve kolekcije su zapravo parovi ključeva i vrednosti, a drugačije se nazivaju asocijativne kolekcije ili mape.
Primere asocijativnih kolekcija je moguće pronaći u svakodnevnom životu. Na primer, u kolekciji građana, matični broj bi bio ključ, dok bi podaci (ime, prezime, adresa) predstavljali bi konkretne vrednosti upakovane u jednu celinu. Ako bismo želeli da pronađemo određenog građanina u kolekciji, dovoljno bi bilo da znamo njegov matični broj, odnosno ključ koji identifikuje sve ostale podatke.
Klase koje omogućavaju upotrebu ovakvih kolekcija u Javi implementiraju interfejs Map. Najpoznatija konkretna implementacija jeste klasa HashMap:
HashMap hashMap = new HashMap();

Nakon instanciranja klase HashMap, vrednosti se dodaju korišćenjem metode put():
1
2
3
HashMap hashMap = new HashMap();
hashMap.put("1234567890123", "John Davidson");
hashMap.put("1234567890124", "Tom Dvorak");

Na ovaj način su unutar kolekcije upisane dve vrednosti. Metodi put() se prosleđuju dva parametra, pri čemu prvi predstavlja ključ, a drugi konkretnu vrednost.
Čitanje vrednosti iz mapa obavlja se korišćenjem metode get() uz upotrebu ključeva koji identifikuju vrednosti. Drugim rečima, kako bismo došli do reference na neku od vrednosti, neophodno je da poznajemo ključ takve vrednosti:
1
2
3
4
5
HashMap hashMap = new HashMap();
hashMap.put("1234567890123", "John Davidson");
hashMap.put("1234567890124", "Tom Dvorak");
System.out.println(hashMap.get("1234567890124"));

Ovakav primer će na izlazu da proizvede ispis Tom Dvorak, zato što je metodi get() prosleđen ključ koji ukazuje na takvu vrednost.
Unutar mapa mogu se naći isključivo zapisi sa jedinstvenim ključevima. Drugim rečima, nije moguće imati dva zapisa sa identičnim ključevima. Svakako, moguće je napisati naredbu za upisivanje dve vrednosti sa istim ključem, ali će ona poslednja biti upisana preko postojeće vrednosti, pa će ključ uvek pokazivati na poslednje upisanu vrednost:
1
2
3
4
5
6
7
HashMap hashMap = new HashMap();
hashMap.put("1234567890123", "John Davidson");
hashMap.put("1234567890124", "Mia Parkinson");
hashMap.put("1234567890124", "Tom Dvorak");
System.out.println(hashMap.get("1234567890124"));

U primeru je obavljeno upisivanje dve različite vrednosti pod istim ključem – 1234567890124. Primer neće proizvesti grešku, ali će na kraju pod ovim ključem biti poslednje upisana vrednost:
Tom Dvorak

U okviru radnog okruženja možete testirati primere iz ovog odeljka - HashMap.
Kako se naziva struktura podataka koja podrazumeva skup parova ključeva i vrednosti?
komplementarna
asocijativna
statička
indeksirana
Odgovori

Vežbe
Vežba 1
1
2
3
4
5
6
7
8
9
10
public class User {
    public int id;
    public String ime;
    public User(int id, String ime) {
        this.id = id;
        this.ime = ime;
    }
}

Takođe, u main() metodi aplikacije postoji sledeći kod:
1
2
3
4
5
6
7
8
9
ArrayList usersToAdd = new ArrayList();
usersToAdd.add(new User(3, "Ben2"));
usersToAdd.add(new User(4, "John"));
usersToAdd.add(new User(5, "Tom"));
ArrayList users = new ArrayList();
users.add(new User(1, "Sem"));
users.add(new User(2, "Peter"));
users.add(new User(3, "Ben"));

Potrebno je sve korisnike iz kolekcije usersToAdd dodati u kolekciju users. Ukoliko korisnik koji se dodaje već postoji unutar kolekcije, potrebno ga je prepisati preko postojećeg. Za poređenje korisnika je potrebno koristiti id vrednosti. Na kraju je potrebno prikazati sve elemente kolekcije users.
Rešenje 1
Rešenje podrazumeva prolazak kroz kolekciju korisnika koji se dodaju. U svakoj iteraciji prolazi se kroz kolekciju postojećih elemenata i obavlja se poređenje id vrednosti. Ukoliko korisnik sa id vrednošću već postoji, element se prepisuje. Kada nema podudaranja id vrednosti, element se dodaje na kraj kolekcije.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
for (int i = 0; i < usersToAdd.size(); i++) {
    boolean userExists = false;
    for (int u = 0; u < users.size(); u++)
        if (((User) users.get(u)).id == ((User) usersToAdd.get(i)).id) {
            users.set(u, (User) usersToAdd.get(i));
            userExists = true;
        }
        if (!userExists)
            users.add(usersToAdd.get(i));
        else
            userExists = false;
    }
for (Object o : users) {
    User u = (User) o;
    System.out.println(u.id + ":" + u.ime);
}

Vežba 2
Na osnovu postojeće klase User (iz prethodne vežbe) kreirana je sledeća kolekcija:
1
2
3
4
5
6
7
ArrayList users = new ArrayList();
users.add(new User(4, "Ben"));
users.add(new User(5, "Tom"));
users.add(new User(6, "Sem"));
users.add(new User(1, "Peter"));
users.add(new User(2, "Donald"));
users.add(new User(3, "Ian"));

Potrebno je sortirati korisnike po ID-ju i emitovati listu na izlaz.
Rešenje
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
int min;
User tmp;
for (int i = 0; i < users.size(); i++) {
    min = i;
    for (int u = i; u < users.size(); u++)
       if (((User) users.get(u)).id < ((User) users.get(min)).id)
           min = u;
       tmp = (User) users.get(min);
       users.set(min, (User) users.get(i));
       users.set(i, tmp);
    }
for (Object o : users) {
    User u = (User) o;
    System.out.println(u.id + ":" + u.ime);
}