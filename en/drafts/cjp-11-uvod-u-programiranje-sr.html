<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="/theme/css/custom.css" media="all" rel="stylesheet" type="text/css"/>
<link href="/theme/css/elegant.prod.9e9d5ce754.css" media="all" rel="stylesheet" type="text/css"/>
<link href="/theme/css/custom.css" media="all" rel="stylesheet" type="text/css"/>
<link href="/theme/fontawesome/css/all.css" rel="stylesheet" type="text/css"/>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Tangerine:wght@700&amp;display=swap" rel="stylesheet">
<script src="https://code.jquery.com/jquery.min.js"></script>
<meta content="Danijela Popović" name="author"/>
<meta content="Upoznavanje sa osnovnim pojmovima iz sveta računara i programiranja
" name="description"/>
<meta content="@DJ_Dani_Serbia" name="twitter:creator"/>
<meta content="article" property="og:type"/>
<meta content="summary" name="twitter:card"/>
<meta content="programiranje, programski jezici, teorija, IT akademija/CoreJavaProgramming/CJP - Modul 1. Svet programiranja, " name="keywords"/>
<meta content="CJP 1.1. Uvod u programiranje" property="og:title"/>
<meta content="https://vlajna95.github.io/en/drafts/cjp-11-uvod-u-programiranje-sr.html" property="og:url"/>
<meta content="Upoznavanje sa osnovnim pojmovima iz sveta računara i programiranja" property="og:description"/>
<meta content="DP Tech" property="og:site_name"/>
<meta content="Danijela Popović" property="og:article:author"/>
<meta content="2021-11-11T00:00:00+01:00" property="og:article:published_time"/>
<meta content="CJP 1.1. Uvod u programiranje" name="twitter:title"/>
<meta content="Upoznavanje sa osnovnim pojmovima iz sveta računara i programiranja" name="twitter:description"/>
<title>CJP 1.1. Uvod u programiranje · DP Tech
</title>
<link href="https://vlajna95.github.io/feeds/atom/all.xml" rel="alternate" title="DP Tech - Full Atom Feed" type="application/atom+xml">
<link href="https://vlajna95.github.io/feeds/rss/all.xml" rel="alternate" title="DP Tech - Full RSS Feed" type="application/rss+xml"/>
</link></link><link href="https://vlajna95.github.io/en\drafts/cjp-11-uvod-u-programiranje-sr.html" rel="canonical"/><script type="application/ld+json">{"@context": "https://schema.org", "@type": "BreadcrumbList", "itemListElement": [{"@type": "ListItem", "position": 1, "name": "DP Tech", "item": "https://vlajna95.github.io/en"}, {"@type": "ListItem", "position": 2, "name": "Drafts", "item": "https://vlajna95.github.io/en\\drafts"}, {"@type": "ListItem", "position": 3, "name": "Cjp 11 uvod u programiranje sr", "item": "https://vlajna95.github.io/en\\drafts/cjp-11-uvod-u-programiranje-sr.html"}]}</script><script type="application/ld+json">{"@context": "https://schema.org", "@type": "Article", "author": {"@type": "Person", "name": "Danijela Popović"}, "publisher": {"@type": "Organization", "name": "DP Tech", "logo": {"@type": "ImageObject", "url": "logo_transparent.png"}}, "headline": "CJP 1.1. Uvod u programiranje", "about": "IT akademija/CoreJavaProgramming/CJP - Modul 1. Svet programiranja", "datePublished": "2021-11-11 00:00"}</script></head>
<body>
<div id="content">
<div class="navbar navbar-static-top">
<div class="navbar-inner">
<div class="container-fluid">
<a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse" title="Prikaži/sakrij meni">
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="https://vlajna95.github.io/en/"><span class="site-name">DP Tech</span> - Your favorite tech blog :smile:</a>
<nav class="nav-collapse collapse">
<ul class="nav pull-right top-menu disclosure-nav" id="menubar">
<li>
<a href="https://vlajna95.github.io/en">Home</a>
</li>
<li><a href="https://vlajna95.github.io/en/categories">Kategorije</a></li>
<li><a href="https://vlajna95.github.io/en/tags">Oznake</a></li>
<li><a href="https://vlajna95.github.io/en/archives">Arhiva članaka</a></li>
<li><form action="https://vlajna95.github.io/en/search.html" class="navbar-search" onsubmit="return validateForm(this.elements['q'].value);"><input class="search-query" id="tipue_search_input" name="q" placeholder="Pretraži" type="text"/></form></li>
</ul>
</nav></div>
</div>
</div>
</div>
<div class="container-fluid">
<div class="row-fluid">
<div class="span1"></div>
<div class="span10">
<article itemscope="">
<div class="row-fluid">
<header class="page-header span10 offset2">
<h1><a href="https://vlajna95.github.io/en/drafts/cjp-11-uvod-u-programiranje-sr.html">
CJP 1.1. Uvod u programiranje
</a>
</h1>
<p><p>Upoznavanje sa osnovnim pojmovima iz sveta računara i programiranja</p></p>
</header>
</div>
<div class="row-fluid">
<div class="span8 offset2 article-content">
<hr/>
<details>
<summary>Rezime</summary>
<ul>
<li>Kompjuter je uređaj koji je sposoban da izvrši proizvoljan broj aritmetičkih i logičkih operacija. </li>
<li>Program je skup instrukcija koje kompjuteru govore šta je potrebno da uradi. </li>
<li>Proces stvaranja kompjuterskih programa naziva se programiranje. </li>
<li>Kompjuterske programe kreiraju programeri, ljudi koji poseduju neophodna znanja kako bi bili u mogućnosti da kreiraju instrukcije koje diriguju kompjuteru. </li>
<li>Prvim kompjuterskim programerom na svetu smatra se Ada Lovelace. </li>
<li>Mašinski jezik je maternji jezik kompjutera, odnosno jedini jezik koji kompjuter razume. </li>
<li>Asembler, odnosno asemblerski jezik, predstavlja programski jezik niskog nivoa, kod kojeg se osnovne programske naredbe pišu korišćenjem unapred utvrđenih reči, koje simbolizuju naredbu koju predstavljaju. </li>
<li>Mašinski i asemblerski jezik u potpunosti su zavisni od fizičkih osobina procesora na kojima se izvršavaju, te od programera u velikoj meri zahtevaju poznavanje same fizičke arhitekture računara. </li>
<li>Programski jezici višeg nivoa u znatno većoj meri koriste elemente prirodnih jezika, uglavnom reči i skraćenice preuzete iz engleskog jezika, te na taj način unapređuju čitljivost i olakšavaju kreiranje programskog koda. </li>
<li>Kompajler i interpreter su kompjuterski programi čija je osnovna svrha generisanje drugih kompjuterskih programa. </li>
</ul>
</details>
<h2 id="uvod">Uvod</h2>
<p>Više od milion godina, ljudska rasa je u konstantnom razvoju. Čovek je intelektualno, spoznajno i fizički prevalio ogroman put od pećinskih skloništa do moderne civilizacije kakvu poznajemo. Iako se o smislu i opravdanosti korišćenja svih blagodeti koje su modernom čoveku na raspolaganju može diskutovati, evidentan je ogroman napredak ljuske vrste, koji se ubrzava eksponencijalnom proporcijom. </p>
<p>Prvih milion godina postojanja, čovek je utrošio na osmišljavanje i kreiranje raznih alata i mašina, koje su mu omogućile da se kreće brže i postigne više. Tako je čovek postao sposoban da uruši planine, ukroti reke i otputuje sa jednog kraja planete Zemlje na drugi za manje od jednog dana. Može se reći da je čovek na taj način svoju fizičku snagu uspeo da uveća nekoliko hiljada puta. </p>
<p>Ono što, ipak, čoveka izdvaja od drugih vrsta jesu alati koje je razvio kako bi proširio i pojačao moć svog intelekta. Prvi takav „alat” jeste jezik (govor i pismo). Govor je čoveku omogućio prenos saznanja i artikulaciju intelekta, a pismo uvid u znanja koja su formirana i razvijana od strane desetina prethodnih generacija. Redovi koje vi upravo čitate idealan su primer moći pisane reči, koja vam omogućava da saznate nešto što do sada niste znali, te da na taj način pokušate da moć svog intelekta iskoristite na potpuno novim poljima. </p>
<p>Artikulisanje govora i pojava pisama omogućili su čovečanstvu da još većom brzinom nastavi napred. Poslednje u nizu velikih dostignuća ljudske vrste jesu kompjuteri – mašine koje su čoveku omogućile proširivanje umne snage do neslućenih granica. </p>
<h2 id="svet-kompjutera">Svet kompjutera</h2>
<p>Pojava kompjutera u potpunosti je promenila svet, kao i način života ljudi. Kompjuteri su danas svuda oko nas, unutar desktop i laptop računara, pametnih telefona, tableta, pametnih časovnika, televizora, automobila, aviona, veš-mašina, šporeta, klima-uređaja, bankomata... </p>
<p>Većina svakodnevnih aktivnosti danas se ne može zamisliti bez kompjutera. Iako toga možda niste ni svesni, veliki broj uobičajenih dnevnih operacija u potpunosti zavisi od kompjutera. Oglašavanje alarma na digitalnom budilniku, podgrevanje doručka u mikrotalasnoj pećnici, putovanje modernim automobilom do posla ili škole, podizanje novca na bankomatima, gledanje omiljenog filma na TV-u, samo su neki od primera najobičnijih aktivnosti koje ne bi bile moguće da kompjuteri ne postoje. Tako se sa pravom može reći da je današnji svet – svet kompjutera. </p>
<figure>
<img alt="Slika 1.1. Svet kompjutera" src="/images/CoreJavaProgramming/1_01_01.jpg"/>
<figcaption>Slika 1.1. Svet kompjutera</figcaption>
</figure>
<p>Pored svakodnevnih čovekovih aktivnosti koje su u potpunosti podržane kompjuterima, i ostale oblasti današnjeg modernog sveta se ne mogu zamisliti bez računara. Tako praktično ne postoji oblast tehnologije, umetnosti, niti nauke, koja u većoj ili manjoj meri ne koristi kompjutere. Laserska operacija oka, projektovanje saobraćajnice, analiza uzorka krvi, štampanje novina, sklapanje automobila na proizvodnoj traci, samo su neki od primera intenzivnog korišćenja kompjutera u svim oblastima poslovanja. </p>
<h3 id="sta-je-kompjuter">Šta je kompjuter?</h3>
<p>Uobičajena definicija kompjutera bi glasila – kompjuter je uređaj koji je sposoban da izvrši proizvoljan broj aritmetičkih i logičkih operacija. Ukoliko se ova rečenica razloži na više delova, može se reći da je kompjuter uređaj koji može da: </p>
<ul>
<li>prihvati neke ulazne podatke </li>
<li>izvrši obradu podataka </li>
<li>proizvede izlaz koji može biti razumljiv čoveku ili nekoj drugoj mašini </li>
</ul>
<p>Iako se pojam kompjutera poistovećuje sa desktop i laptop računarima, veoma je bitno razumeti da kompjuteri postoje u veoma širokom spektru oblika. Na hiljade kompjutera skriveno je u uređajima oko nas iako toga u nekim situacijama nismo ni svesni. Takvi kompjuteri se mogu nazvati specijalizovanim, s obzirom na to da su namenjeni obavljanju unapred utvrđenih operacija. Na primer, kompjuteri u modernim automobilima namenjeni su kontroli funkcionisanja motora i ostalih uređaja. Tako je primarni kompjuter u automobilu namenjen kontrolisanju ubrizgavanja goriva, rada ventila i slično. Takav kompjuter, razumljivo je, ne može se koristiti za pretraživanje interneta. Stoga su nama mnogo bliži kompjuteri koji se mogu nazvati univerzalnim. Oni su namenjeni obavljanju širokog skupa univerzalnih operacija, koje isključivo zavise od potreba korisnika. Univerzalni kompjuteri danas primarno postoje u obliku desktop, laptop i tablet računara, kao i u obliku pametnih telefona. Takvi uređaji se mogu koristiti za obavljanje najrazličnijih operacija, od jednostavnog surfovanja internetom, pisanja teksta, pregleda audio i video zapisa, pa sve do upravljanja i kontrolisanja ostalih vrsta digitalnih uređaja. </p>
<h3 id="sta-su-programi">Šta su programi?</h3>
<p>Pored sve mistike koja okružuje kompjutere u celini, bitno je razumeti da oni nisu nikakve magične mašine, odnosno da samostalno nisu u stanju da urade baš ništa. Svaki kompjuter kontroliše program, što je zapravo skup instrukcija koje kompjuteru govore šta je potrebno da uradi. Bez takvih instrukcija, kompjuter bi bio mašina koja ne bi imala nikakvu praktičnu upotrebu (slika 1.2). </p>
<figure>
<img alt="Slika 1.2. Program udahnjuje život kompjuteru" src="/images/CoreJavaProgramming/1_01_02.jpg"/>
<figcaption>Slika 1.2. Program udahnjuje život kompjuteru</figcaption>
</figure>
<p>Sa odgovarajućim skupom instrukcija, objedinjenim unutar programa, kompjuter može postati alat koji je moguće koristiti za međukontinentalnu komunikaciju, lansiranje nuklearnog projektila, istraživanje novih molekula koji mogu izlečiti najteže bolesti itd. S obzirom na to da se kompjuteri rađaju kao uređaji bez ikakve svesti, jasno je da se procesom pisanja instrukcija, objedinjenih unutar programa, kompjuterima udahnjuje život. Takav proces drugačije se naziva programiranje, što je i primarna tematika ovog kompletnog programa. </p>
<h3 id="sta-je-programiranje">Šta je programiranje?</h3>
<p>Ono što kompjutere izdvaja od ostalih mašina koje je čovek tokom vremena napravio jeste mogućnost programabilnosti. To praktično znači da je kompjuter, uopšteno posmatrano, jedna univerzalna alatka koja u zavisnosti od instrukcija koje joj se proslede može obavljati različite poslove. Upravo u ovoj činjenici krije se i najveća moć ovih mašina – potpuna proizvoljnost programabilnosti. </p>
<p>Proces stvaranja kompjuterskih programa naziva se programiranje. Tako je programiranje čin pisanja instrukcija koje omogućavaju da kompjuter obavi neku operaciju. Iako uopšteno vlada drugačije mišljenje, programiranje je veoma kreativan proces, koji u velikoj meri sadrži razne aspekte umetnosti, inženjerstva i nauke. </p>
<h3 id="ko-su-programeri">Ko su programeri?</h3>
<p>Kompjuterske programe kreiraju programeri, ljudi koji poseduju neophodna znanja kako bi bili u mogućnosti da napišu instrukcije koje diriguju kompjuterom. Moderno kompjutersko programiranje može se smatrati relativno novom profesijom, starom tek nešto više od pedesetak godina. Ipak, prvi oblici programiranja zabeleženi su znatno ranije, u vreme postojanja mehaničkih računara, značajno drugačije konstrukcije od onih kakve danas poznajemo. </p>
<p>Prvim kompjuterskim programerom na svetu smatra se Ada Lovelace (slika 1.3), ćerka pesnika Lorda Bajrona (engl. Lord Byron). </p>
<figure>
<img alt="Slika 1.3. Ada Lovelace, prvi programer na svetu[^1]" src="/images/CoreJavaProgramming/1_01_03.jpg"/>
<figcaption>Slika 1.3. Ada Lovelace, prvi programer na svetu[^1]</figcaption>
</figure>
<p>Ada Lovelace je 1840. godine na prevod dobila stručni tekst Charles Babbagea, pionirskog kompjuterskog konstruktora. Tekst je sadržao prezentaciju dizajna i funkcionisanja njegovog novog mehaničkog kompjutera koji se zvao Analytical Engine. Tokom prevođenja ovog teksta sa francuskog na engleski, Ada Lovelace je napisala prvi skup instrukcija, čiji je cilj bio da omogući računanje Bernulijevih brojeva na mehaničkom kompjuteru. U čast ovoj inovativnoj ženi, Ministarstvo odbrane Sjedinjenih Američkih Država je 1980. godine novokreirani jezik za internu upotrebu nazvalo Ada. </p>
<h2 id="programski-jezici">Programski jezici</h2>
<p>Kompjuter, program, programer i programiranje su međusobno povezani, zavisni pojmovi. Programer procesom koji se naziva programiranje stvara program koji kompjuteru govori šta je potrebno da uradi. Ipak, ovom zaokruženom procesu, kako bi bio potpun, nedostaje još jedan element. Reč je o jeziku kojim se programer tokom procesa stvaranja programa obraća mašini. </p>
<p>U svakodnevnom životu, ljudi se međusobno sporazumevaju korišćenjem prirodnih jezika (engl. natural languages), kao što su engleski, ruski, srpski itd. Jezik je ništa drugo do unapred utvrđen skup pravila, koja se primenjuju kako bi se misli artikulisale i prezentovale nekoj drugoj osobi. Na identičan način obavlja se i proces komunikacije sa kompjuterima. Ipak, kompjuteri ne razumeju nijednu vrstu prirodnih jezika koje ljudi koriste, te je stoga neophodno kompjuteru se obratiti na njegovom maternjem jeziku. </p>
<p>Srce svakog kompjutera jeste centralna procesorska jedinica (engl. Central Processing Unit, CPU) ili jednostavno procesor. Tokom svog rada, procesor koristi i razne druge komponente koje su sastavni deo računara, ali je ipak procesor komponenta sa kojom se direktno komunicira prilikom prosleđivanja instrukcija koje je potrebno da kompjuter izvrši. Tako je komunikacija sa kompjuterom zapravo razgovor sa centralnom procesorskom jedinicom. </p>
<p><strong>CPU</strong> <br/>
Centralna procesorska jedinica srce je svakoga računara. Ona obavlja osnovne aritmetičke i logičke operacije koje su definisane instrukcijama unutar programa. </p>
<figure>
<img alt="Slika 1.4. Centralna procesorska jedinica (engl. CPU)" src="/images/CoreJavaProgramming/1_01_04.jpg"/>
<figcaption>Slika 1.4. Centralna procesorska jedinica (engl. CPU)</figcaption>
</figure>
<p>Tokom vremena, dizajn kompjuterskih procesora se umnogome menjao, ali je osnovni način njihovog funkcionisanja ostao nepromenjen. Svaki procesor ciklično obavlja aritmetičke i logičke operacije nad operandima. Tako su kompjuterski procesori, i pored ogromne strukturalne kompleksnosti, namenjeni obavljanju veoma jednostavnih operacija, kao što su sabiranje ili poređenje dva broja. Ipak, moderni procesori mogu obaviti milione takvih operacija u samo jednom deliću sekunde. <br/>
Kompjuterski procesor nije u stanju da razume jezik kojim se ljudi svakodnevno služe. Štaviše, procesor ne može razumeti ni bilo kakve kompleksnije naredbe. Sve što procesor razume jeste serija bitova, odnosno nula i jedinica, koji se prevode u određene instrukcije. Takva serija bitova, koja se interpretira u različite naredbe, naziva se mašinski jezik. </p>
<h3 id="masinski-jezik">Mašinski jezik</h3>
<p>Mašinski jezik je maternji jezik kompjutera, odnosno jedini jezik koji kompjuter razume. Programski kod ovakvog jezika sačinjen je iz niza nula i jedinica, a svaka od takvih cifara naziva se bit. </p>
<p><strong>Binarni brojni sistem</strong> <br/>
U svakodnevnom životu, za predstavljanje brojeva koristi se dekadni brojni sistem, koji se sastoji iz deset cifara (1, 2, 3, 4, 5, 6, 7, 8, 9 i 0). Kombinovanjem ovih deset cifara formiraju se svi ostali brojevi. Ipak, pored decimalnog brojnog sistema, na koji smo svi navikli, u matematici postoji još nekoliko brojčanih sistema, odnosno načina na koje je moguće predstaviti brojeve. Jedan od takvih sistema posebno je značajan za digitalnu elektroniku i kompjutere. Reč je o binarnom brojnom sistemu. <br/>
Binarni brojni sistem poseduje samo dve cifre, 0 i 1. Zbog ove činjenice, često se kaže da je baza ovakvog sistema 2, dok je baza, na primer, decimalnog brojnog sistema 10. <br/>
Binarni brojni sistem osnovni je sistem za predstavljanje podataka u kompjuteru. Kompjuterski procesor rukuje isključivo binarnim podacima, dok se identičan format koristi i za čuvanje podataka unutar bilo koje vrste kompjuterske memorije. Korišćenje ovakvog brojčanog sistema u digitalnoj elektronici uslovljeno je osobinama samih elemenata od kojih su sačinjene kompjuterske komponente, prevashodno procesori. Moderni procesori sastavljeni su od stotina miliona poluprovodničkih elemenata (tranzistora), koji se ponašaju kao prekidači, koji mogu imati dva stanja (uključeno-isključeno, tačno-netačno, nula-jedan). Upravo zbog ovakvih strukturalnih osobina kompjuterskih elemenata, digitalna elektronika se zasniva na binarnom brojnom sistemu. <br/>
Iako možda na prvi pogled izgleda kao da je binarni brojni sistem prilično ograničen postojanjem samo dve cifre, to zapravo nije tako. Štaviše, bilo koji broj decimalnog brojnog sistema može se predstaviti kao binarni, i obrnuto. <br/>
Jedan broj predstavljen binarnim brojnim sistemom izgleda ovako: <br/>
<code>1101</code><br/>
Kada biste prikazani broj videli izvan konteksta ove lekcije, verovatno biste ga pročitali kao hiljadu sto jedan. Zbog toga se često, prilikom pisanja brojeva specifičnih brojnih sistema, pribegava naznačavanju baze koju takav brojni sistem koristi. Da bismo naglasili da gore navedeni broj pripada binarnom sistemu, potrebno je napisati: <br/>
<code>1101(2-subskript)</code><br/>
Kao što možete videti, unutar subskripta navodi se osnova brojnog sistema koji se koristi. Naravno, kao što je već rečeno, za binarni brojni sistem baza je 2, zbog postojanja samo dve cifre. <br/>
Prikazani binarni broj može se veoma lako prevesti u decimalni, odnosno u oblik koji je mnogo razumljiviji svima nama: <br/>
<code>1101(2) = 1*20 + 0*21 + 1*22 + 1*23 = 13</code><br/>
Iz prikazanog računa lako se može razumeti logika koja se koristi pri konverziji binarnih brojeva u decimalne. Svaka cifra binarnog broja, počevši od krajnje desne, množi se sa brojem 2, stepenovanim u zavisnosti od pozicije koju takva cifra poseduje unutar kompletnog binarnog broja. Tako se prva cifra u prikazanom primeru množi se 20, druga sa 21, treća sa 22 i tako dalje. Nakon obavljanja računanja na ilustrovani način, utvrđuje se da binarni broj 1101 u decimalnom brojnom sistemu ima vrednost 13. <br/>
Brojeve decimalnog brojnog sistema takođe je moguće na lak način pretvoriti u binarne. Za obavljanje takvog posla koristi se nešto drugačija logika, koja podrazumeva deljenje decimalnog broja brojem dva i beleženjem ostataka. Kompletan postupak pretvaranja decimalnog broja 13 u binarni izgledao bi ovako: <br/>
<code>13:2 = 6 i ostatak 1</code><br/>
<code>6:2 = 3 i ostatak 0</code><br/>
<code>3:2 = 1 i ostatak 1</code><br/>
<code>1:2 = 0 i ostatak 1</code><br/>
Kao što možete videti iz ilustrovanog primera, decimalni broj koji je potrebno pretvoriti u binarni deli se brojem dva. Zatim se i svaki dobijeni količnik deli brojem dva. Ostatak prilikom deljenja bilo kojeg broja brojem dva može biti ili 0 ili 1. Tako dobijeni ostaci prilikom deljenja formiraju binarni broj. Vrednost binarnog broja se sklapa zdesna nalevo. Na kraju se može napisati sledeće: <br/>
<code>1101(2) = 13(10)</code></p>
<p>Korišćenje mašinskog jezika za upućivanje instrukcija računaru, kao što i sami možete pretpostaviti, može biti veoma zahtevan i dugotrajan posao. Na primer, kako bi se obavilo jednostavno sabiranje brojeva 1234 i 4321 korišćenjem mašinskog jezika, neophodno je napisati kod ilustrovan slikom 1.5. </p>
<figure>
<img alt="Slika 1.5. Program za sabiranje brojeva 1234 i 4321 napisan mašinskim jezikom" src="/images/CoreJavaProgramming/1_01_05.jpg"/>
<figcaption>Slika 1.5. Program za sabiranje brojeva 1234 i 4321 napisan mašinskim jezikom</figcaption>
</figure>
<p>Prikazani set naredbi napisanih mašinskim jezikom predstavlja programiranje na najnižem mogućem nivou, odnosno direktno obraćanje kompjuterom procesoru. Prikazani skupovi bitova, odnosno nula i jedinica, predstavljaju sve neophodne instrukcije koje se upućuju kompjuteru kako bi on obavio posao koji je programer zamislio. U ovom trenutku se može postaviti sledeće pitanje – na koji način je programer znao kako izgledaju naredbe koje je potrebno da uputi kompjuteru kako bi on obavio sabiranje dva broja iz prikazanog primera? </p>
<p>Odgovor na ovo pitanje leži u pojmu set instrukcija (engl. instruction set). Svaki procesor poznaje unapred utvrđeni set instrukcija, koji je hardverski upisan specifičnom kombinacijom tranzistora unutar dela procesora koji je namenjen dekodiranju instrukcija. Ukoliko se procesoru uputi instrukcija koju ne poznaje, on je naravno neće izvršiti. Iz ovoga se može zaključiti da je mašinski jezik u potpunosti zavisan od procesora na kojem se izvršava. Jedan isti program napisan mašinskim kodom ne može se izvršiti na dva procesora različitih osobina. </p>
<p>Kako programer ne bi morao da svoj program piše iznova i iznova za svaki procesor koji postoji na tržištu, tokom vremena su razvijene različite arhitekture setova instrukcija (engl. instruction set architecture, ISA). Arhitektura seta instrukcija je samo apstrakcija, odnosno ugovor ili standard koji definiše kakve instrukcije je potrebno da kompjuter poznaje. Reč je o jednom od najznačajnijih ugovora u kompjuterskom svetu, koji omogućava izvršavanje identičnih programa na širokom spektru različitih tipova kompjutera. Postojanje arhitekture seta instrukcija, na primer, omogućava izvršavanje identičnog kompjuterskog programa na računaru sa 486 procesorom, ali i na modernom računaru sa Intel i7 procesorom poslednje generacije. </p>
<p><strong>Arhitektura seta instrukcija i mikroarhitektura</strong> <br/>
S obzirom na to da je arhitektura seta instrukcija samo apstrakcija, odnosno standard, ona ni u kojoj meri ne određuje samu mikroarhitekturu, što je način na koji je procesor interno dizajniran, kada su u pitanju njegove fizičke komponente. U prilog ovome ide i činjenica da se jedan isti kompjuterski program bez ikakvih problema može izvršiti i na računaru sa AMD Ryzen, ali i na računaru sa Intel Kaby Lake procesorom. I pored velikih razlika u mikroarhitekturi između dve navedene familije procesora, obe dele identičnu arhitekturu seta instrukcija – x86. <br/>
U prethodnim redovima zaronili smo dublje u samu suštinu mašinskog jezika i načina na koji se procesoru u izvornom obliku upućuju instrukcije. Sve što je rečeno umnogome će vam pomoći u razumevanju pojmova koji slede. Nešto ranije, slikom 1.5. prikazan je primer koji ilustruje mašinski kod za obavljanje sabiranja dva broja. Zamislite sada situaciju u kojoj biste morali korišćenjem mašinskog jezika da napišete nešto složeniji program ili čak program koji bi se izvršavao na modernim kompjuterima. Sa pravom se može reći da bi takav posao iscrpeo i najupornijeg i najsmirenijeg programera, pa bi ishod uglavnom bio odustajanje. Stoga je do prvog koraka u uprošćavanju programerskog posla došlo 1949. godine, kada su različitim binarnim naredbama dodeljeni nešto razumljiviji nazivi koji su oslikavali njihovu svrhu. Na taj način stvoren je asemblerski jezik ili skraćeno asembler (engl. assembly language or assembler). </p>
<div class="question">
<p>Koji je osnovni brojni sistem računara?</p>
<div class="answers"><input id="osnovni_brojni_sistem_correct" name="osnovni_brojni_sistem_correct" type="hidden" value="inranib"/><input id="inranib" name="osnovni_brojni_sistem" type="radio" value="binarni"/><label for="inranib">binarni</label><br/>
<input id="inlatko" name="osnovni_brojni_sistem" type="radio" value="oktalni"/><label for="inlatko">oktalni</label><br/>
<input id="inlamicedaskeh" name="osnovni_brojni_sistem" type="radio" value="heksadecimalni"/><label for="inlamicedaskeh">heksadecimalni</label><br/>
<input id="inlamiced" name="osnovni_brojni_sistem" type="radio" value="decimalni"/><label for="inlamiced">decimalni</label><br/>
</div>
<button class="ok" data-correct="osnovni_brojni_sistem_correct" data-question="osnovni_brojni_sistem" onclick="checkAnswer(this, 'Bravo!', 'Hmmm... no.')" type="button">OK</button></div>
<p><strong>Asembler</strong> <br/>
Asembler, odnosno asemblerski jezik, često skraćeno imenovan kao asm, predstavlja programski jezik niskog nivoa, kod kojeg se osnovne programske naredbe pišu korišćenjem unapred utvrđenih reči, koje simbolizuju naredbu koju predstavljaju. Takve asemblerske jezičke konstrukcije veoma često se nazivaju i simboli, a sam asembler simboličkim jezikom. Korišćenjem naziva za pisanje programskih naredbi, asemblerski jezik omogućio je znatno ugodnije pisanje programa, s obzirom na to da korišćenjem asemblera programer nije morao pamtiti serije nula i jedinica, od kojih su sačinjene naredbe. Ipak, i pored toga što je značajno jednostavniji za razumevanje, asemblerski jezik funkcioniše na identičan način kao i mašinski, s obzirom na to da između asemblerskih i mašinskih naredbi skoro uvek postoji odnos jedan prema jedan. <br/>
Posao sabiranja brojeva 1234 i 4321, čije obavljanje je nešto ranije ilustrovano korišćenjem mašinskog jezika, ovoga puta upotrebom asemblerskog jezika može biti postignuto kao na slici 1.6. </p>
<figure>
<img alt="Slika 1.6. Program za sabiranje brojeva 1234 i 4321 napisan asemblerskim jezikom" src="/images/CoreJavaProgramming/1_01_06.jpg"/>
<figcaption>Slika 1.6. Program za sabiranje brojeva 1234 i 4321 napisan asemblerskim jezikom</figcaption>
</figure>
<p>Kao što možete videti, kod asemblerskog jezika značajno je razumljiviji od mašinskog. Umesto skupova nula i jedinica, sada su za upućivanje naredbi procesoru korišćene naredbe napisane engleskim rečima. Na primer, MOV znači premesti, odnosno upiši, a ADD saberi. AX, BX, CX i slično označavaju memorijske lokacije, odnosno procesorske registre koji se koriste za čitanje i upisivanje podataka. Kao što i sami možete zaključiti, pojava asemblerskog jezika predstavljala je ogroman korak napred za programersku profesiju. </p>
<p>Nešto ranije je rečeno da kompjuteri, odnosno procesorske jedinice, mogu da razumeju isključivo mašinski jezik. U prethodnim redovima smo govorili o asembleru, pa je pitanje koje se samo nameće sledeće – kako je to kompjuter preko noći naučio jedan novi jezik i postao sposoban da, pored mašinskog, razume i asemblerski kod? </p>
<p>Naravno, kompjuter nije naučio asemblerske naredbe, već se one, kako bi procesor bio u stanju da ih razume, pre izvršavanja prevode u oblik mašinskog koda. Svaka asemblerska naredba prevodi se u odgovarajući skup nula i jedinica. Takav posao obavlja program koji se naziva asembler. On je zadužen da asemblerske naredbe prevede u mašinski kod (slika 1.7). </p>
<figure>
<img alt="Slika 1.7. Prevođenje asemblerskog koda u mašinski" src="/images/CoreJavaProgramming/1_01_07.jpg"/>
<figcaption>Slika 1.7. Prevođenje asemblerskog koda u mašinski</figcaption>
</figure>
<p>Sa slike 1.7. možete videti na koji način asemblerski program obavlja pretvaranje instrukcija napisanih asemblerskim jezikom u mašinski kod procesora. Jasno je da je kompletna magija asemblerskog jezika smeštena u parčetu softvera koji se naziva asembler. </p>
<p>Baš kao i mašinski jezik, i asembler je u potpunosti zavisan od seta instrukcija koje procesor podržava. To znači da procesori različite arhitekture instrukcija zahtevaju postojanje različitih asemblerskih programa. </p>
<p>Pojava asemblera u velikoj meri je olakšala posao programerima. Ipak, to jednostavno nije bilo dovoljno kako bi se posao pisanja kompjuterskih programa još više uprostio, ubrzao i standardizovao. Stoga je apstrakcija podignuta jednu lestvicu više, stvaranjem programskih jezika višeg nivoa. </p>
<h3 id="jezici-viseg-nivoa">Jezici višeg nivoa</h3>
<p>Obe vrste programskih jezika kojima su posvećeni redovi za nama ubrajaju se u jezike niskog nivoa. Mašinski i asemblerski jezik u potpunosti su zavisni od fizičkih osobina procesora na kojima se izvršavaju, te od programera u velikoj meri zahtevaju poznavanje same fizičke arhitekture računara. Zbog toga su jezici niskog nivoa veoma zahtevni za učenje i iziskuju dosta vremena za pisanje programa. Upravo zbog toga je tokom vremena kreiran veliki broj programskih jezika višeg nivoa, koji su apstrahovanjem fizičkih detalja kompjutera znatno uprostili i ubrzali posao pisanja programa. </p>
<p>Za razliku od jezika niskog nivoa, programski jezici višeg nivoa, u znatno većoj meri koriste elemente prirodnih jezika, uglavnom reči i skraćenice preuzete iz engleskog jezika, te na taj način unapređuju čitljivost i olakšavaju kreiranje programskog koda. Kako biste u najboljoj meri razumeli prednost jezika višeg nova, pogledaćemo kako bi izgledao jednostavan program za sabiranje dva broja, napisan jednim od jezika višeg nivoa (slika 1.8). </p>
<figure>
<img alt="Slika 1.8. Program za sabiranje brojeva 1234 i 4321 napisan jezikom C" src="/images/CoreJavaProgramming/1_01_08.jpg"/>
<figcaption>Slika 1.8. Program za sabiranje brojeva 1234 i 4321 napisan jezikom C</figcaption>
</figure>
<p>Realizacija identičnog problema, koja je već ilustrovana korišćenjem mašinskog i asemblerskog jezika, u prikazanom primeru je postignuta korišćenjem programskog jezika C, jednog od jezika višeg nivoa. Ono što odmah možete primetiti jeste značajno kraći, jednostavniji i razumljiviji programski kod. </p>
<p>Pored redukovanja kompleksnosti, jezici višeg nivoa poseduju i različite sisteme koji u potpunosti oslobađaju programera potrebe rukovanja određenim aspektima izvršavanja programa. Na primer, većina programskih jezika višeg nivoa automatski upravlja alokacijom i oslobađanjem memorije koju program tokom izvršavanja koristi. </p>
<p>Odnos između kompjutera i jezika nižeg i višeg nivoa može biti ilustrovan kao na slici 1.9. </p>
<figure>
<img alt="Slika 1.9. Hijerarhija različitih tipova programskih jezika" src="/images/CoreJavaProgramming/1_01_09.jpg"/>
<figcaption>Slika 1.9. Hijerarhija različitih tipova programskih jezika</figcaption>
</figure>
<p>Kao što sa slike 1.9. možete videti, kretanjem od hardvera ka jezicima višeg nivoa, povećava se apstrakcija, a smanjuje kompleksnost. To praktično znači da jezike višeg nivoa karakteriše viši stepen apstrakcije, a mašinski jezik značajno veća kompleksnost. </p>
<p>Tokom vremena napravljen je veliki broj programskih jezika višeg nivoa. Ukoliko danas počinjete da učite programiranje, gotovo sigurno će to biti učenje nekog od jezika višeg nivoa. Takođe, različiti jezici višeg nivoa se umnogome međusobno razlikuju, po mogućnostima, performansama, sintaksi i nivou apstrakcije. Neki jezici višeg nivoa omogućavaju i izlet u low-level programiranje, tako što dozvoljavaju da delovi kompjuterskog programa budu napisani asemblerskim jezikom konkretnog tipa procesora. </p>
<p>Sve prednosti koje jezici višeg nivoa donose na neki način moraju biti realizovane. S obzirom na to da je jedini jezik koji kompjuter razume mašinski, jasno je da programi napisani jezicima višeg nivoa na neki način moraju biti prevedeni u mašinski jezik pre nego što ih kompjuter izvrši, baš kao što je to bio slučaj i sa asemblerskim kodom. Programski jezici višeg nivoa za obavljanje takvog posla koriste dve veoma značajne komponente modernog programiranja – kompajlere i interpretere. </p>
<p>Kompajleri i interpreteri su međusobno nezavisne komponente programskih jezika višeg nivoa, koje identičan posao prevođenja koda viših jezika u mašinski obavljaju na različite načine. </p>
<p>Kompajler (engl. compiler) je kompjuterski program čija je osnovna svrha generisanje drugih kompjuterskih programa. Kompajler prevodi izvorni kod programa napisanih jezicima višeg nivoa u mašinski, kako bi takav kod mogao kompjuter da izvrši. Posao koji kompajler obavlja drugačije se naziva kompajliranje, a jezici koji koriste kompajler - kompajlirani jezici. Posao kompajliranja obavlja se odjednom, pre nego što je potrebno da se određeni program napisan višim jezikom izvrši na nekom računaru. Rezultat kompajliranja jeste izvršni fajl sa sadržajem napisanim mašinskim kodom. <br/>
Interpreter obavlja identičan posao kao i kompajler, ali na nešto drugačiji način. Za razliku od kompajlera, interpreter obavlja prevođenje manjih delova izvornog koda, i to u toku njegovog izvršavanja. Tako korišćenjem interpretera nije potrebno prevesti kompletan program, već se prevođenje obavlja u delovima, prilikom izvršavanja. </p>
<p>Razlike između kompajliranja i interpretiranja ilustrovane su slikom 1.10. </p>
<figure>
<img alt="Slika 1.10. Razlika između načina rada kompajlera i interpretera" src="/images/CoreJavaProgramming/1_01_10.jpg"/>
<figcaption>Slika 1.10. Razlika između načina rada kompajlera i interpretera</figcaption>
</figure>
<p>Kao što možete videti, procesom kompajliranja vrši se generisanje potpuno novog fajla koji u sebi sadrži kompletan mašinski kod prevedenog programa. Jednom kompajliran, program se može izvršavati proizvoljan broj puta na različitim računarima. Sa druge strane, procesom interpretiranja, ne proizvodi se mašinski kod koji predstavlja kompletan program koji je potrebno izvršiti. Interpretiranje se obavlja iz više koraka, instrukciju po instrukciju, tako da se mašinski kod generiše iz delova, koje odmah nakon prevođenja izvršava kompjuter. </p>
<p>Proces interpretiranja omogućava brže inicijalno pokretanje programa, zato što se ne obavlja prevođenje kompletnog izvornog koda odjednom. Sa druge strane, kada se jednom obavi proces kompajliranja izvornog koda jezika višeg nivoa u mašinski, svako sledeće pokretanje i izvršavanje je značajno brže, s obzirom na to da program već postoji u mašinskom obliku. Proces kompajliranja poseduje još jednu prednost u odnosu na interpretiranje. S obzirom na to da se kompletan izvorni kod prevodi pre izvršavanja, kompajler poseduje mogućnost provere napisanog izvornog koda. Ukoliko izvorni kod sadrži neku sintaksnu grešku, kompajler neće biti u stanju da takav program prevede, pa samim tim program neće ni biti izvršen. Na taj način se sprečava izvršavanje programa koji u svom izvornom kodu poseduju neku grešku. Sa druge strane, detekcija sintaksnih grešaka nije moguća prilikom procesa interpretiranja, s obzirom na to da interpreter prevodi kod iz delova, instrukciju po instrukciju, i to tokom njegovog izvršavanja. Ukoliko izvorni kod koji se interpretira sadrži grešku, do nje će sasvim sigurno doći tokom izvršavanja samog programa. </p>
<p><strong>Programski jezik je samo specifikacija</strong> <br/>
Moderni programski jezici teško se mogu podeliti na kompajlirane i interpretirane. S obzirom na to da je određeni programski jezik samo specifikacija, konkretnim procesom implementacije jezika utvrđuje se način na koji će on biti preveden u mašinski. To praktično znači da skoro svaki jezik može biti i interpretiran i kompajliran, a da konkretna metoda prevođenja zavisi od onoga ko bude kreirao implementaciju konkretnog jezika. Programski jezik nije ništa drugo do skup određenih pravila koja su unapred dogovorena. Takav skup pravila određuje sintaksu jezika, koja na kraju definiše izgled i strukturu koda koju će programeri pisati. Da bi programski jezik višeg nivoa uistinu i postao živ, neophodno je napisati programsku komponentu koja će obavljati prevođenje koda takvog jezika u mašinski. Prilikom realizacije takve komponente potrebno je konkretno realizovati sva ona jezička pravila koja su prethodno dogovorena specifikacijom, objedinjenom programskim jezikom. <br/>
Prevođenje modernih programskih jezika višeg nivoa često se obavlja kombinovanjem dve opisane tehnike, odnosno kombinovanjem kompajliranja i interpretiranja. Implementacije nekih jezika, sa druge strane, zasnivaju se isključivo na jednoj od dve pomenute metode prevođenja izvornog koda. Na primer, programski jezik C dizajniran je prevashodno kako bi bio kompajliran, što je i najčešći slučaj kod njegovih implementacija. Ista situacija postoji i kod programskih jezika Objective C i Swift, jezika koji se koriste za kreiranje programa za uređaje kompanije Apple. S druge strane, veoma popularan programski jezik višeg nivoa koji se zove JavaScript jeste primer interpretiranog programskog jezika. Jezici kao što su C#, Java i PHP su primarno kompajlirani, ali proces njihovog prevođenja takođe uključuje i neke osobine interpretiranja. </p>
<h3 id="programski-jezici-za-rukovanje-podacima">Programski jezici za rukovanje podacima</h3>
<p>Programski jezici koji su spomenuti na kraju prethodnog poglavlja mogu se smatrati jezicima opšte namene (engl. general-purpose programming language). To su jezici koji se mogu koristiti za rešavanje širokog skupa problema. Pored ovakvih jezika, postoje i jezici specifične namene (engl. domain-specific language). Takvi jezici namenjeni su rešavanju određenog skupa problema prilikom kreiranja kompjuterskih programa. Idealan primer takvih jezika jesu jezici koji se danas intenzivno koriste za rukovanje podacima. Najpopularniji jezik takve vrste je SQL (engl. Structured Query Language). Danas ovaj jezik postoji u obliku velikog broja različitih implementacija (MySQL, Microsoft SQL, PostgreSQL, Oracle SQL, SQLite), pa se može reći da je jedan od najznačajnijih specifičnih jezika, namenjenih rukovanju podacima. Teško da postoji osoba koja se danas smatra programerom a da dobro ne poznaje ovaj jezik. </p>
<h3 id="moderni-programski-jezici-u-sirokoj-upotrebi">Moderni programski jezici u širokoj upotrebi</h3>
<p>U prethodnim redovima spomenuti su neki od programskih jezika višeg nivoa koji su danas u širokoj upotrebi. Veoma zahtevan posao jeste izmeriti popularnost nekog jezika, s obzirom na to da se takva karakteristika može posmatrati kroz prizmu mnogih različitih parametara (broja napisanih programa, veličine programerske zajednice, količine dostupnih pozicija novih radnih mesta itd.). Stoga ćemo se u ovom trenutku uzdržati od spekulacija o tome koji je programski jezik najpopularniji i najkorišćeniji, jer tako nešto jednostavno nije moguće utvrditi. Ono što ipak sa sigurnošću možemo reći jeste koji su to sve jezici danas u intenzivnoj upotrebi, bez namere da bilo koji jezik ni na koji način rangiramo. Pregled najpopularnijih jezika današnjice dat je u tabeli 1.1. </p>
<figure>
<div markdown="1">
| Programski jezik | Opis |
| --- | --- |
| C | Predak većine modernih jezika, C je programski jezik koji se i danas, 45 godina nakon prvog predstavljanja, koristi, pretežno za obavljanje low-level programiranja, koje zahteva što bolju kontrolu hardverskih uređaja računara; C je u velikoj meri uticao na većinu programskih jezika navedenih u ovoj tabeli; danas se pretežno koristi za sistemsko programiranje niskog nivoa; na primer, osnova operativnog sistema Linux (Linux kernel) napisana je u potpunosti korišćenjem programskog jezika C; takođe, veliki deo operativnog sistema Windows napisan je ovim jezikom; tvorac programskog jezika C je Dennis Ritchie. |
| C++ | C++ je još jedan od jezika starije generacije, koji i u modernom vremenu nalazi svoju primenu; nastao je po ugledu na jezik C, sa nekoliko proširenja koje jezik C nije posedovao; danas se koristi u različitim oblastima programiranja, od programiranja niskog nivoa, pa sve do aplikacija sa grafičkim korisničkim okruženjem; ipak, zbog svoje kompleksnosti, za programiranje višeg nivoa, programeri najčešće koriste druge jezike koji su na raspolaganju; kreirao ga je Bjarne Stroustrup 1983. godine |
| C# | C# je jedan od jezika .NET porodice koji je kreirala kompanija Microsoft; reč je o jeziku opšte namene, koji se danas intenzivno koristi za kreiranje desktop, web i mobilnih aplikacija; predstavljen je 2000. godine. 
| PHP | PHP je jedan od najpopularnijih jezika današnjice, prevashodno namenjen web programiranju; karakteriše ga jednostavna sintaksa, tako da spada u jezike koji nisu teški za učenje; idealan je primer konstantnog povećavanja apstrakcije kompjuterskog programiranja, odnosno sve većeg udaljavanja od načina na koji funkcioniše kompjuter, s obzirom na to da su implementacije ovog jezika napisane korišćenjem jezika C i C++; to je idealan primer korišćenja već postojećih jezika, za kreiranje novih, višeg nivoa; nastao je 1995. godine, a njegov tvorac je Rasmus Lerdorf. |
| Java | Java se, po mnogim parametrima, može smatrati najpopularnijim programskim jezikom današnjice; namenjena je programiranju opšte namene, pa se tako može koristiti za pisanje aplikacija za veoma širok spektar uređaja; to je ujedno i najveća prednost ovog jezika, koji je kreiran sa ciljem da njegovo izvršavanje bude moguće na što većem broju različitih kompjuterskih uređaja; danas se Java, ipak, najviše koristi za web programiranje i razvoj aplikacija za uređaje pogonjene Android operativnim sistemom; Java je nastala 1995. godine, a njeni tvorci su James Gosling i kompanija Sun Microsystems. |
| JavaScript | Osnovni jezik klijentskog programiranja web aplikacija, JavaScript, jedan je od osnovnih gradivnih blokova modernog weba; koristi se kako bi web stranice učinio interaktivnijim, a takođe je i osnovna tehnologija kojom se kreiraju web igre i animacija; sastavni je deo svih modernih web browsera; prvi put se pojavio 1995. godine, kao sastavni deo Netscape web browsera; njegov tvorac je Brendan Eich. |
| SQL | Jezik čija je jedina namena rukovanje podacima smeštenim u relacionim bazama podataka; danas postoji veliki broj implementacija ovog jezika, koje su kreirale vodeće IT kompanije; ovo je jezik koji primarno omogućava čitanje, pisanje, brisanje i izmenu podataka, ali i kreiranje baza i tabela, kao i definisanje jednostavne logike po ugledu na programske jezike opšte namene; jezik je kreirala 1974. kompanija IBM. |
| Objective C / Swift | Jezici koji se koriste za kreiranje aplikacija za uređaje kompanije Apple; Objective C je jezik koji je originalno korišćen za programiranje aplikacija za OS X i iOS operativne sisteme; Objective C su 1984. godine kreirali Tom Love i Brad Cox, proširivanjem jezika C, objektno orijentisanim mogućnostima koje su preuzete iz programskog jezika Smalltalk; tako je Objective C nastao kombinovanjem ova dva jezika; osnova jezika je apsolutno identična jeziku C, dok je dodatak u vidu objektno orijentisane podrške apsolutno identičan ovoj funkcionalnosti u Smalltalk jeziku; programski jezik Swift, kompanija Apple, predstavila je 2014. godine kao alternativu Objective C jeziku; jezik Swift karakteriše korišćenje znatno modernijih pristupa, kao i pojednostavljena sintaksa. |
| Python | Python je programski jezik opšte namene čije su osnovne osobine jednostavnost sintakse, čitljivost i jezgrovitost; to praktično znači da se korišćenjem ovog jezika neki problem može rešiti sa znatno manje linija koda nego što je to slučaj sa nekim drugim jezicima; ovaj jezik se danas prevashodno koristi za web programiranje, kao alternativa jezicima PHP, Java ili C#; klasičan je primer jezika čiji se izvorni kod interpretira; prvi put se pojavio 1991. godine, a njegov tvorac je Guido van Rossum. |
| Perl | Još jedan od jezika opšte namene, koji se može koristiti za pisanje različitog tipa softvera; jedan je od interpretiranih jezika, a njegov interpreter se može integrisati u veliki broj postojećih sistema; najveću primenu ima na webu, a posebno je poznat po bogatim mogućnostima obrade teksta; kreirao ga je 1987. godine Larry Wall. |
</div>
<figcaption>Tabela 1.1. Najpopularniji programski jezici višeg nivoa</figcaption>
</figure>
<p>Kako bismo rekapitulirali sve ono što je u ovoj lekciji rečeno o programskim jezicima, data je slika 1.11, koja ilustruje njihov razvoj tokom vremena. </p>
<figure>
<img alt="Slika 1.11. Hronologija najznačajnijih programskih jezika višeg nivoa" src="/images/CoreJavaProgramming/1_01_11.jpg"/>
<figcaption>Slika 1.11. Hronologija najznačajnijih programskih jezika višeg nivoa</figcaption>
</figure>
<h2 id="pocetak-uzbudljivog-putovanja">Početak uzbudljivog putovanja</h2>
<p>Čitajući ovu lekciju, mogli ste da naslutite samo delić uzbudljivosti koju krije svet programiranja. Naravno, posle ovolike količine informacija, možda se osećate zbunjeno. Takav osećaj je potpuno normalan i karakterističan za svakoga ko ulazi u lavirintni svet programiranja. Ipak, razloga za brigu nema s obzirom na to da je nastavak ovog programa koncipiran tako da vam na sistematičan i postupan način omogući upoznavanje sveta programiranja. Uzbudljivo putovanje može da počne! </p>
<div class="footnote">
<hr/>
<ol>
<li id="fn:1">
<p>Izvor: https://en.wikipedia.org/wiki/Ada_Lovelace <a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
</ol>
</div><br/>
<hr/>
</div>
<section class="span2" id="article-sidebar">
<h4>Reading time estimation</h4>
<p>~36 min.</p>
<h4>Published</h4>
<time datetime="2021-11-11T00:00:00+01:00" itemprop="dateCreated">Thursday, November 11, 2021 at 00:00</time>
<h4><built-in 0x000001815dadb0a0="" at="" index="" method="" object="" of="" str=""></built-in></h4>
<ol class="multi-parts-list">
</ol>
<h4>Category</h4>
<a class="category-link" href="https://vlajna95.github.io/en/categories/it-akademija">IT akademija</a> / 
<a class="category-link" href="https://vlajna95.github.io/en/categories/it-akademija/corejavaprogramming">CoreJavaProgramming</a> / 
<a class="category-link" href="https://vlajna95.github.io/en/categories/it-akademija/corejavaprogramming/cjp-modul-1-svet-programiranja">CJP - Modul 1. Svet programiranja</a>
<h4>Tags</h4>
<ul class="list-of-tags tags-in-article">
<li><a href="https://vlajna95.github.io/en/tags/programiranje">programiranje 
</a></li>
<li><a href="https://vlajna95.github.io/en/tags/programski-jezici">programski jezici 
</a></li>
<li><a href="https://vlajna95.github.io/en/tags/teorija">teorija 
</a></li>
</ul>
<h4>Social networks</h4>
<div id="sidebar-social-link">
<a href="https://fb.me/dani.vlajna" rel="nofollow noopener noreferrer" target="_blank" title="">
<svg aria-label="Facebook" role="img" viewbox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><rect fill="#1877f2" height="512" rx="15%" width="512"></rect><path d="M355.6 330l11.4-74h-71v-48c0-20.2 9.9-40 41.7-40H370v-63s-29.3-5-57.3-5c-58.5 0-96.7 35.4-96.7 99.6V256h-65v74h65v182h80V330h59.6z" fill="#fff"></path></svg>
</a>
<a href="https://twitter.com/DJ_Dani_Serbia" rel="nofollow noopener noreferrer" target="_blank" title="">
<svg aria-label="Twitter" role="img" viewbox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><rect fill="#1da1f3" height="512" rx="15%" width="512"></rect><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37" fill="#fff"></path></svg>
</a>
<a href="https://www.youtube.com/DanijelaPopovic" rel="nofollow noopener noreferrer" target="_blank" title="">
<svg aria-label="YouTube" fill="#ed1d24" role="img" viewbox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><rect height="512" rx="15%" width="512"></rect><path d="m427 169c-4-15-17-27-32-31-34-9-239-10-278 0-15 4-28 16-32 31-9 38-10 135 0 174 4 15 17 27 32 31 36 10 241 10 278 0 15-4 28-16 32-31 9-36 9-137 0-174" fill="#fff"></path><path d="m220 203v106l93-53"></path></svg>
</a>
<a href="https://github.com/vlajna95" rel="nofollow noopener noreferrer" target="_blank" title="">
<svg aria-label="GitHub" role="img" viewbox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><rect fill="#1B1817" height="512" rx="15%" width="512"></rect><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z" fill="#fff"></path></svg>
</a>
</div>
</section>
</div>
</article>
<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div aria-hidden="true" class="pswp" role="dialog" tabindex="-1">
<!-- Background of PhotoSwipe.
         It's a separate element as animating opacity is faster than rgba(). -->
<div class="pswp__bg"></div>
<!-- Slides wrapper with overflow:hidden. -->
<div class="pswp__scroll-wrap">
<!-- Container that holds slides.
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
<div class="pswp__container">
<div class="pswp__item"></div>
<div class="pswp__item"></div>
<div class="pswp__item"></div>
</div>
<!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
<div class="pswp__ui pswp__ui--hidden">
<div class="pswp__top-bar">
<!--  Controls are self-explanatory. Order can be changed. -->
<div class="pswp__counter"></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title="Share"></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
<!-- element will get class pswp__preloader--active when preloader is running -->
<div class="pswp__preloader">
<div class="pswp__preloader__icn">
<div class="pswp__preloader__cut">
<div class="pswp__preloader__donut"></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class="pswp__share-tooltip"></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class="pswp__caption">
<div class="pswp__caption__center"></div>
</div>
</div>
</div>
</div></div>
<div class="span1"></div>
</div>
</div>

<footer>
<div>
<span class="site-name">DP Tech</span> - Your favorite tech blog :smile:
</div>
<div id="fpowered">
Pokreće: <a href="http://getpelican.com/" rel="nofollow noopener noreferrer" target="_blank" title="Pelican početna strana">Pelican</a>. 
Tema: <a href="https://elegant.oncrashreboot.com/" rel="nofollow noopener noreferrer" target="_blank" title="Početna strana Elegant teme">Elegant</a>. 
</div>
</footer><script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
<script src="https://vlajna95.github.io/en/theme/js/elegant.prod.9e9d5ce754.js"></script>
<script src="https://vlajna95.github.io/en/theme/js/custom.js"></script>
<script>
function validateForm(query) {
return(query.length>0);
}
</script>
<script>
function checkAnswer(origin) {
var question_name = $(origin).attr("data-question");
var correct_answer_element = $(origin).attr("data-correct");
var correct_answer_id = $("#"+correct_answer_element).val();
var correct_answer_label = $("label[for="+correct_answer_id+"]").text();
var chosen_answer_id = $("input[name="+question_name+"]:checked").attr("id");
var chosen_answer_label = $("label[for="+chosen_answer_id+"]").text();
if(correct_answer_id == chosen_answer_id) {
alert("Bravo!");
}
else {
alert("Hmmm... ne. \n" + correct_answer_label);
}
$("input[name="+question_name+"]").attr("disabled", true);
}
</script>
<script>
    (function () {
        if (window.location.hash.match(/^#comment-\d+$/)) {
            $('#comment_thread').collapse('show');
        }
    })();
    window.onhashchange=function(){
        if (window.location.hash.match(/^#comment-\d+$/))
            window.location.reload(true);
    }
    $('#comment_thread').on('shown', function () {
        var link = document.getElementById('comment-accordion-toggle');
        var old_innerHTML = link.innerHTML;
        $(link).fadeOut(200, function() {
            $(this).text('Click here to hide comments').fadeIn(200);
        });
        $('#comment_thread').on('hidden', function () {
            $(link).fadeOut(200, function() {
                $(this).text(old_innerHTML).fadeIn(200);
            });
        })
    })
</script>
</body>
<!--
Theme: Elegant built for Pelican 
License: MIT
-->
</html>